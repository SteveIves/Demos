;;*****************************************************************************
;;
;; Routine:     product_load_bulk
;;
;; Author:      "Steve Ives"
;;
;; Company:     "Synergex Professional Services Group"
;;
;;*****************************************************************************
;;
;; WARNING:     This code was generated by CodeGen. Any changes that you make
;;              to this file will be lost if the code is regenerated.
;;
;; This code is supplied as seen and without warranty or support, and is used
;; at your own risk. Neither the author or Synergex accept any responsability
;; for any loss or damage which may result from the use of this code. This text
;; must remain unaltered in this file at all times. Possession or use of this
;; code, or any modified version of this code, indicates your acceptance of
;; these conditions.
;;
;;*****************************************************************************
;;
;; Possible return values from this routine are:
;;
;;  true    Table loaded
;;  false   Error (see a_errtxt)
;;
function product_load_bulk ,^val

    required in  a_dbchn    ,int        ;;Connected database channel
    optional out a_rowcount ,n          ;;Rows inserted
    optional out a_errtxt   ,a          ;;Error text
    endparams

    .include "CONNECTDIR:ssql.def"
    .include "INVMAS" repository, stack record="file_record"
    .include "PRODUCT" repository, stack record="database_record"

    stack record localData
        ok          ,boolean    ;;Return status
        chIn        ,int        ;;Input file channel  (data file)
        chOut       ,int        ;;Output file channel (delimited file)
        cursor      ,int        ;;Database cursor
        dberror     ,int        ;;Database error number
        length      ,int        ;;Length of error message
        transaction ,boolean    ;;Is there a SQL transaction in progress
        errtxt      ,a512       ;;Error message
        sqlCommand  ,string     ;;Bulk insert SQL statement
        fileSpec    ,string     ;;Bulk insert data file
        errorFile   ,string     ;;Bulk insert errors file
        sqlFile     ,string     ;;Bulk load SQL statement file
    endrecord

proc

    init localData
    ok = true

    ;;Open the data file associated with the mapped structure
    try 
    begin
        open(chIn=%syn_freechn,i:i,"DAT:invmas.ism")
    end
    catch (ex)
    begin
        ok = false
        errtxt = "Failed to open input file DAT:invmas.ism"
        clear chIn
    end
    endtry

    ;;Open the delimited output file and build the SQL statement
    try 
    begin
        ;;Get the TEMP path
        data tempPath, a256
        xcall getlog("TEMP",tempPath,length)
        if (tempPath(length:1)!="\")
            tempPath = %atrim(tempPath) + "\"

        ;;Define the output file name and make sure there isn't an old one out there
        fileSpec = %atrim(tempPath)+"PRODUCT.BULK_LOAD"
        xcall delet(fileSpec)

        ;;Open the output file
        open(chOut=%syn_freechn,o:s,fileSpec)

        ;;Define the error and SQL command file names
        errorFile = fileSpec + ".ERRORS"
        sqlFile   = fileSpec + ".SQL"

        ;;Build the SQL statement
        sqlCommand = "BULK INSERT [PRODUCT] FROM '"+fileSpec+"' WITH (FIELDTERMINATOR='|',ROWTERMINATOR='\n',FIRSTROW=2,KEEPNULLS,ERRORFILE='"+errorFile+"')"
        
        ;;Save the SQL statement to a file (for debugging)
        begin
            data tmpCh, i4, 0
            xcall delet(sqlFile)
            open(tmpch,o:s,sqlFile)
            writes(tmpCh,sqlCommand)
            close tmpCh
        end

        ;;Make sure there are no previous error files hanging around
        xcall delet(errorFile)
        xcall delet(errorFile + ".Error.Txt")
    end
    catch (ex)
    begin
        ok = false
        errtxt = "Failed to open output file " + fileSpec
        clear chOut
    end
    endtry

    ;Put column headings into the output file
    writes(chOut,"SKU|PRODUCT_GROUP|DESCRIPTION|PRICE_GROUP|SELLING_PRICE|LAST_SALE|LAST_COST_PRICE|AVERAGE_COST_PRICE|QTY_IN_STOCK|QTY_ALLOCATED|QTY_IN_TRANSIT|QTY_ON_ORDER|REFERENCE|PUBLISHER|AUTHOR|TYPE|RELEASE_DATE|RATING|")

    if (ok)
    begin
        ;;Read records from the input file and write the output file
        repeat
        begin
            data row, string, ""

            ;;Get the next record from the file and map it into the database record
            reads(chIn,file_record,eof)
            xcall product_map(file_record,database_record)

            ;;Put the record in the delimited bulk load file
            row = row + %atrim(SKU)
            row = row +"|"
            row = row + %atrim(PRODUCT_GROUP)
            row = row +"|"
            row = row + %atrim(DESCRIPTION)
            row = row +"|"
            row = row + %atrim(PRICE_GROUP)
            row = row +"|"
            row = row + %string(SELLING_PRICE)
            row = row +"|"
            if (LAST_SALE)
                row = row + %string(LAST_SALE,"XXXX-XX-XX")
            row = row +"|"
            row = row + %string(LAST_COST_PRICE)
            row = row +"|"
            row = row + %string(AVERAGE_COST_PRICE)
            row = row +"|"
            row = row + %string(QTY_IN_STOCK)
            row = row +"|"
            row = row + %string(QTY_ALLOCATED)
            row = row +"|"
            row = row + %string(QTY_IN_TRANSIT)
            row = row +"|"
            row = row + %string(QTY_ON_ORDER)
            row = row +"|"
            row = row + %atrim(REFERENCE)
            row = row +"|"
            row = row + %atrim(PUBLISHER)
            row = row +"|"
            row = row + %atrim(AUTHOR)
            row = row +"|"
            row = row + %atrim(TYPE)
            row = row +"|"
            if (RELEASE_DATE)
                row = row + %string(RELEASE_DATE,"XXXX-XX-XX")
            row = row +"|"
            row = row + %atrim(RATING)
            row = row +"|"
            writes(chOut,row)
        end
    end

eof,
    close chIn
    close chOut

    ;;Start a database transaction
    if (ok)
    begin
        transaction = false
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction = true
        else
        begin
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
            ok = false
        end
    end

    ;;Open a database cursor for the command
    if (ok)
    begin
        if (%ssc_open(a_dbchn,cursor,sqlCommand,SSQL_NONSEL)==SSQL_FAILURE)
        begin
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
            clear cursor
            ok = false
        end
    end

    ;;Execute the cursor
    if (ok)
    begin
        data rowsAffected, i4
        if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD,,rowsAffected)==SSQL_NORMAL) then
        begin
            if (^passed(a_rowcount))
                a_rowcount = rowsAffected
        end
        else
        begin
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to execute SQL statement"
            ok = false
        end
    end

    ;;Close the cursor
    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
                ok = false
            end
        end
    end

    ;;Commit or rollback the transaction
    if (transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;Clean up
    if (ok)
    begin
        xcall delet(fileSpec)
        xcall delet(sqlFile)
        xcall delet(errorFile)
        xcall delet(errorFile + ".Error.Txt")
    end

    ;;Return the error text
    if (^passed(a_errtxt))
        a_errtxt = errtxt

    freturn ok

endfunction
