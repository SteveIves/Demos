<CODEGEN_FILENAME><structure_name>_select_rows.dbl</CODEGEN_FILENAME>
;//*****************************************************************************
;//
;// Title:        sql_select_rows.tpl
;//
;// Description:  Template to generate a Synergy function which retrieves
;//               multiple rows from a table in a SQL Server database.
;//
;// Author:       Steve Ives, Synergex Professional Services Group
;//
;// Copyright:    ©Synergex International Inc.  All rights reserved.
;//
;// WARNING:      If you were given this code by a Synergex employee then you
;//               may use and modify it freely to generate code for your
;//               applications. However, you may not under any circumstances
;//               distribute this code, or any modified version of this code,
;//               to any third party without first obtaining written permission
;//               to do so from Synergex. In using this code you accept that it
;//               is provided as is, and without support or warranty. Neither
;//               Synergex or the author accept any responsibility for any
;//               losses or damages of any nature which may arise from the use
;//               of this code. This header information must remain unaltered
;//               in the code at all times. Possession of this code, or any
;//               modified version of this code, indicates your acceptance of
;//               these terms.
;//
;// $Revision: 1 $
;//
;// $Date: 2012-02-15 23:52:19-06:00 $
;//
;;*****************************************************************************
;;
;; Routine:     <structure_name>_select_rows
;;
;; Author:      <AUTHOR> (<ENV:USERNAME>)
;;
;; Company:     <COMPANY>
;;
;; Created:     <DATE> at <TIME>
;;
;;*****************************************************************************
;;
;; WARNING:     This code was generated by <CODEGEN_VERSION>.  Any changes that
;;              you make to this file will be lost if the code is regenerated.
;;
;; This code is supplied as seen and without warranty or support, and is used
;; at your own risk. Neither the author or Synergex accept any responsability
;; for any loss or damage which may result from the use of this code. This text
;; must remain unaltered in this file at all times. Possession or use of this
;; code, or any modified version of this code, indicates your acceptance of
;; these conditions.
;;
;;*****************************************************************************
;;
;; Possible return values from this routine are:
;;
;;   true   Success, rows returned
;;   false  Error, see a_errtxt
;;
function <structure_name>_select_rows ,^val

    required in  a_dbchn    ,int    ;Connected database channel
    required in  a_where    ,a      ;Where clause to use
    required out a_data     ,int    ;Memory handle with matching rows rows
    optional in  a_estrows  ,int    ;Estimated row count
    optional out a_rows     ,int    ;Row count
    optional out a_errtxt   ,a      ;Error text
    endparams

    .include "CONNECTDIR:ssql.def"
    .include "<STRUCTURE_NOALIAS>" repository, stack record="<structure_name>"
    .include "<STRUCTURE_NOALIAS>" repository, structure="row", nofields

    stack record local_data
        ok      ,boolean    ;;OK to continue
        dberror ,int        ;;Database error number
        cursor  ,int        ;;Database cursor
        length  ,int        ;;Length of a string
        mh      ,int        ;;Memory handle
        mi      ,int        ;;Memory increment size
        ms      ,int        ;;Memory size (allocated rows)
        mc      ,int        ;;Memory content (used rows)
        errtxt  ,a256       ;;Error message text
        sql     ,string     ;;SQL statement
    endrecord

.proc

    init <structure_name>,local_data
    ok = true

    ;;-------------------------------------------------------------------------
    ;;Determine increment size for dynamic memory
    ;;
    if (^passed(a_estrows) && a_estrows) then
        mi = a_estrows * 1.2
    else
        mi = 50

    ;;-------------------------------------------------------------------------
    ;;Open a cursor for the SELECT statement
    ;;
    sql = "SELECT "
    <FIELD_LOOP>
    &   "<FIELD_SQLNAME><,>"
    </FIELD_LOOP>
    &   " FROM <STRUCTURE_NAME> "

    if (^passed(a_where) && a_where)
        sql = %atrim(sql) + " WHERE " + %atrim(a_where)

    if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_SELECT)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to open cursor"
    end

    ;;-------------------------------------------------------------------------
    ;;Bind host variables to receive the data
    ;;
    if (ok)
    begin
        if (%ssc_define(a_dbchn,cursor,<STRUCTURE_FIELDS>,
		<FIELD_LOOP>
		<IF NOTDATE>
		&    <structure_name>.<field_name><,>
		</IF>
		<IF DATE>
		&    ^a(<structure_name>.<field_name>)<,>
		</IF>
		</FIELD_LOOP>
        &   )==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
    end

    ;;-------------------------------------------------------------------------
    ;;Move data to host variables
    ;;
    if (ok)
    begin

        ;;Allocate initial dynamic memory
        mh = %mem_proc(DM_ALLOC+DM_STATIC,(^size(row)*(ms=mi)))

        repeat
        begin
            using (%ssc_move(a_dbchn,cursor,1)) select
            (SSQL_NORMAL),
            begin
                if ((mc+=1)>ms)
                    mh = %mem_proc(DM_RESIZ,(^size(row)*(ms+=mi)),mh)
                ^m(row[mc],mh) = <structure_name>
            end
            (SSQL_NOMORE),
            begin
                if (mc) then
                    mh = %mem_proc(DM_RESIZ,(^size(row)*mc),mh)
                else
                    mh = %mem_proc(DM_FREE,mh)
                exitloop
            end
            (SSQL_FAILURE),
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to execute SQL statement"
                set mh, mc = %mem_proc(DM_FREE,mh)
                exitloop
            end
            endusing
        end
    end

    ;;-------------------------------------------------------------------------
    ;;Close the database cursor
    ;;
    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;;-------------------------------------------------------------------------
    ;;Return data
    ;;
    if (mh)
        a_data = mh

    ;;-------------------------------------------------------------------------
    ;;Return row count
    ;;
    if (^passed(a_rows))
        a_rows = mc

    ;;-------------------------------------------------------------------------
    ;;If there was an error message, return it to the calling routine
    ;;
    if (^passed(a_errtxt))
        if (ok) then
            clear a_errtxt
        else
            a_errtxt=errtxt

    freturn ok

endfunction

