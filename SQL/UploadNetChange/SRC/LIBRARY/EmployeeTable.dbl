;;*****************************************************************************
;;
;; Title:       EmployeeTable.dbl
;;
;; Type:        Class
;;
;; Description: This class provides the ability to interact with a SQL Server
;;              database table named Employee using records defined
;;              by the repository structure EMPLOYEE and data
;;              stored in the file DAT:employee.ism.
;;
;; Author:      Steve Ives
;;
;; Company:     Synergex Professional Services Group
;;
;;*****************************************************************************
;;
;; WARNING:     This code was generated by CodeGen. Any changes that you make
;;              to this file will be lost if the code is regenerated.
;;
;;*****************************************************************************
;;
import System.Collections
import DatabaseTools

namespace DatabaseTools

    ;;; <summary>
    ;;; Class used to interact with the database table Employee
    ;;; </summary>
    public class EmployeeTable extends DatabaseTableBase

        ;;SQL Statements
        private static mCreateTableStatement    ,string
        private static mInsertStatement         ,string
        private static mSelectByKeyStatement    ,string
        private static mSelectAllStatement      ,string
        private static mSelectWhereStatement    ,string
        private static mDeleteByKeyStatement    ,string

        ;;Defines the layout of the synergy record used to transfer data
        ;;to and from the database. Used with %ssc_strdef() and populated
        ;;by the loadRecordSpec() method which is called from the constructor
        private record recordSpec
            fieldCount          ,d3
            group fields        ,[11]a
                fieldType       ,a1         ;Field type (A/D/I)
                fieldSize       ,d5         ;Field length
                fieldDecimals   ,d2         ;Implied decimal places (for D)
            endgroup
        endrecord

        ;;; <summary>
        ;;; Constructor
        ;;; </summary>
        ;;; <param name="aDb">DatabaseConnection object</param>
        public method EmployeeTable
            required in aDb, @DatabaseConnection
            endparams
            parent(aDb)
        proc
            loadRecordSpec()
            loadSqlStatements()
        endmethod

        ;;; <summary>
        ;;; Create a Employee table in the database
        ;;; </summary>
        ;;; <returns>True for success, false for failure</returns>
        public method Create, boolean
            endparams
            stack record local_data
                ok          ,boolean    ;;Return status
                cursor      ,int        ;;Database cursor
                transaction ,boolean    ;;Transaction in process
            endrecord
        proc
            init local_data
            ok = true

            ;;Start a new transaction
            if (ok = startTransaction())
                transaction = true

            ;;Create the database table and primary key
            if (ok)
            begin
                if (ok=openNonSelectCursor(mCreateTableStatement,cursor))
                begin
                    ok = executeNonSelectCursor(cursor)
                    closeCursor(cursor,ok)
                end
            end

            ;;Create index 1 (Department ID)
            if (ok)
            begin
                if (ok=openNonSelectCursor("CREATE  INDEX IX_Employee_EmpDept ON Employee(EmpDept ASC)",cursor))
                begin
                    ok = executeNonSelectCursor(cursor)
                    closeCursor(cursor,ok)
                end
            end

            ;;Create index 2 (Last name)
            if (ok)
            begin
                if (ok=openNonSelectCursor("CREATE  INDEX IX_Employee_EmpLastName ON Employee(EmpLastName ASC)",cursor))
                begin
                    ok = executeNonSelectCursor(cursor)
                    closeCursor(cursor,ok)
                end
            end

            ;;Grant access permissions
            if (ok&&(ok=openNonSelectCursor("GRANT ALL ON Employee TO PUBLIC",cursor)))
            begin
                ok = executeNonSelectCursor(cursor)
                closeCursor(cursor,ok)
            end

            ;;Commit or rollback the transaction
            if (transaction)
                ok = commitOrRollback(ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Deletes the Employee table from the database
        ;;; </summary>
        ;;; <returns>True for success, false for failure</returns>
        public method Drop, boolean
			endparams
			.include "CONNECTDIR:ssql.def"
            stack record local_data
                ok          ,boolean    ;;Return status
                cursor      ,int        ;;Database cursor
                transaction ,boolean    ;;Transaction in progress
            endrecord
        proc

            init local_data
            ok = true

            ;;Start a database transaction
            if (ok = startTransaction())
                transaction = true

            ;;Open cursor for DROP TABLE statement
            ;;
            if (ok)
                ok=openNonSelectCursor("DROP TABLE Employee",cursor)

            ;;Execute DROP TABLE statement
            ;;
            if (ok)
            begin
                if (!(ok = executeNonSelectCursor(cursor)))
                begin
                    data dbErrText, a1024
                    data length, int
                    if (%ssc_getemsg(mDb.Channel,dbErrText,length,,mErrorNumber)==SSQL_NORMAL)
                    begin
                        ;;Check if the error was that the table did not exist
                        if (mErrorNumber==-3701) then
                        begin
                            clear mErrorMessage
                            ok = true
                        end
                        else
                            mErrorMessage = atrim(dbErrText)
                    end
                end
            end

            ;;Close the cursor
            closeCursor(cursor,ok)

            ;;Commit or rollback the transaction
            if (transaction)
                ok = commitOrRollback(ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Deletes all data from the Employee table in the database
        ;;; </summary>
        ;;; <returns>True for success, false for failure</returns>
        public method Clear, boolean
            endparams
            stack record local_data
                ok          ,boolean    ;;Return status
                cursor      ,int        ;;Database cursor
                transaction ,boolean    ;;Transaction in process
            endrecord
        proc

            init local_data
            ok = true

            ;;Start a database transaction
            if (ok = startTransaction())
                transaction = true

            ;;Open cursor for the SQL statement
            if (ok)
                ok = openNonSelectCursor("TRUNCATE TABLE Employee",cursor)

            ;;Execute SQL statement
            if (ok)
                ok = executeNonSelectCursor(cursor)

            ;;Close the cursor
            closeCursor(cursor,ok)

            ;;Commit or rollback the transaction
            if (transaction)
                ok = commitOrRollback(ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Checks if the Employee table exists in the database
        ;;; </summary>
        ;;; <returns>True if the table exists, false if not (or an error occurred)</returns>
        public method Exists, boolean
			endparams
			.include "CONNECTDIR:ssql.def"
            .include "EMPLOYEE" repository, stack record="employee"
            stack record local_data
                ok          ,boolean    ;;Return value
                cursor      ,int        ;;Database cursor
                table_name  ,a128       ;;Retrieved table name
            endrecord
        proc

            init employee,local_data

            ;;Open a cursor for the SELECT statement
            ;;
            ok = openSelectCursor("SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='Employee'",cursor)

            ;;Bind host variables to receive the data
            if (ok)
                if (%ssc_define(mDb.Channel,cursor,1,table_name)==SSQL_FAILURE)
                    ok = getDatabaseError("Failed to bind variable")

            ;;Move data to host variables
            if (ok)
                if (%ssc_move(mDb.Channel,cursor,1)==SSQL_FAILURE)
                    ok = false

            ;;Close the cursor
            closeCursor(cursor,ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Inserts a new row into the Employee table in the database
        ;;; </summary>
        ;;; <param name="argEmployee">Record containing data to insert</param>
        ;;; <returns>True for success, false for failure</returns>
        public method InsertRow, boolean
            required in argEmployee, strEmployee
            endparams
            stack record local_data
                ok              ,boolean    ;;Return status
                cursor          ,int        ;;Database cursor
                transaction     ,boolean    ;;Transaction in progress
                recEmployee, strEmployee
            endrecord
        proc

            init local_data
            ok = true

            ;;Start a database transaction
            if (ok = startTransaction())
                transaction = true

            ;;Open a cursor for the INSERT statement
            if (ok)
                ok = openNonSelectCursor(mInsertStatement,cursor)

            ;;Prepare a structure definition to define where the data for each column
            ;;comes from within the record
            ;;
            if (ok)
                ok = defineStructure(cursor,1,recordSpec,recEmployee)

            ;;Insert the row into the database
            if (ok)
            begin
                ;;Load the data into our local buffer
                recEmployee = argEmployee

                ;;If requested, clean the data
                if (mCleanData)
                    cleanEmployeeData(recEmployee)

                ;;If requested, null terminate empty alpha fields
                if (mEmptyAlphaNull)
                    nullTerminateEmptyAlphas(recEmployee)

                ;;Execute the INSERT statement
                ok = executeNonSelectCursor(cursor)
            end

            ;;Close the cursor
            closeCursor(cursor,ok)

            ;;Commit or rollback the transaction
            if (transaction)
                ok = commitOrRollback(ok)

            mreturn ok

        endmethod

		;;; <summary>
		;;; Inserts multiple new rows into the Employee table in the database.
		;;; </summary>
		;;; <param name="argRecords">Collection of any number of boxed Employee records to insert.</param>
		;;; <returns>True for success, false for failure.</returns>
		public method InsertRows        ,boolean
			required in  argRecords     ,@ArrayList
			endparams
		proc
			mreturn doInsertRows(argRecords,^null,0)
		endmethod

		;;; <summary>
		;;; Inserts multiple new rows into the Employee table in the database
		;;; and returns a collection containing the data for any rows that failed to
		;;; insert.
		;;; </summary>
		;;; <param name="argRecords">Collection of any number of boxed Employee records to insert.</param>
		;;; <param name="argExceptions">Collection of records that failed to insert.</param>
		;;; <returns>True for success, false for failure.</returns>
		public method InsertRows        ,boolean
			required in  argRecords     ,@ArrayList
			required out argExceptions  ,@ArrayList
			endparams
		proc
			if (argExceptions==^null)
				argExceptions = new ArrayList()
			mreturn doInsertRows(argRecords,argExceptions,0)
		endmethod

		;;; <summary>
		;;; Inserts multiple new rows into the Employee table in the database
		;;; and logs any errors to a supplied log channel.
		;;; </summary>
		;;; <param name="argRecords">Collection of any number of boxed Employee records to insert.</param>
		;;; <param name="argLogCh">Channel to log error messages to.</param>
		;;; <returns>True for success, false for failure.</returns>
		public method InsertRows        ,boolean
			required in argRecords      ,@ArrayList
			required in argLogCh        ,i
			endparams
		proc
			mreturn doInsertRows(argRecords,^null,argLogCh)
		endmethod

		;;; <summary>
		;;; Inserts multiple new rows into the Employee table in the database,
		;;; returns a collection containing the data for any rows that failed to
		;;; insert, and also logs errors to s supplied log channel.
		;;; </summary>
		;;; <param name="argRecords">Collection of any number of boxed Employee records to insert.</param>
		;;; <param name="argExceptions">Collection of records that failed to inserted.</param>
		;;; <param name="argLogCh">Channel to log error messages to.</param>
		;;; <returns>True for success, false for failure.</returns>
		public method InsertRows        ,boolean
			required in  argRecords     ,@ArrayList
			required out argExceptions  ,@ArrayList
			required in  argLogCh       ,i
			endparams
		proc
			if (argExceptions==^null)
				argExceptions = new ArrayList()
			mreturn doInsertRows(argRecords,argExceptions,argLogCh)
		endmethod

		private method doInsertRows, boolean
			required in argRecords      ,@ArrayList
			required in argExceptions   ,@ArrayList
			required in argLogCh        ,i
			endparams
			stack record local_data
				ok          ,boolean    ;;Return status
				cursor      ,int        ;;Database cursor
				transaction ,boolean    ;;Transaction in progress
				continue    ,int        ;;Continue after an error
				recEmployee, strEmployee
				objEmployee, @strEmployee
			endrecord
		proc

			init local_data
			ok = true

			;;Start a database transaction
			if (ok = startTransaction())
				transaction = true

			;;Open a cursor for the INSERT statement
			if (ok)
				ok = openNonSelectCursor(mInsertStatement,cursor)

			;;Prepare a structure definition to define where the data for each column
			;;comes from within the record
			if (ok)
				ok = defineStructure(cursor,1,recordSpec,recEmployee)

			;;Insert the rows into the database
			if (ok)
			begin
				data cnt, int
				foreach objEmployee in argRecords
				begin
					;;Load data into the bound record
					recEmployee = (strEmployee)objEmployee

					;;If requested, clean the data
					if (mCleanData)
						cleanEmployeeData(recEmployee)

					;;If requested, null terminate empty alpha fields
					if (mEmptyAlphaNull)
						nullTerminateEmptyAlphas(recEmployee)

					;;Execute the INSERT statement
					if (!(ok = executeNonSelectCursor(cursor)))
					begin
						;;We got an error, lets decide what to do with it
						clear continue

						;;Are we logging errors?
						if (argLogCh)
						begin
							writes(argLogCh,mErrorMessage)
							continue=1
						end

						;;Are we processing exceptions?
						if (argExceptions!=^null)
						begin
							argExceptions.Add((@strEmployee)recEmployee)
							continue=1
						end

						if (continue)
						begin
							ok = true
							nextloop
						end

						exitloop
					end
				end
			end

			;;Close the cursor
			closeCursor(cursor,ok)

			;;Commit or rollback the transaction
			if (transaction)
				ok = commitOrRollback(ok)

			mreturn ok

		endmethod

        ;;; <summary>
        ;;; Retrieves a row from the Employee table in the database
        ;;; </summary>
        ;;; <param name="argEmpId">Primary key segment emp_id</param>
        ;;; <param name="argEmployee">Employee record to return data in</param>
        ;;; <returns>True for success, false for failure</returns>
        public method SelectRow, boolean
            required in  argEmpId, D6
            required out argEmployee, strEmployee
			endparams
			.include "CONNECTDIR:ssql.def"
            stack record local_data
                ok              ,boolean    ;;OK to continue
                cursor          ,int        ;;Database cursor
            endrecord
        proc

            ok = true

            ;;Open a cursor for the SELECT statement
            if (%ssc_open(mDb.Channel,cursor,mSelectByKeyStatement,SSQL_SELECT,,1,argEmpId)==SSQL_FAILURE)
                ok = getDatabaseError("Failed to open cursor")

            ;;Prepare a structure definition to define where the data for each column
            ;;goes to within the record
            if (ok)
                ok = defineStructure(cursor,1,recordSpec,argEmployee)

            ;;Move data to host variables
            if (ok)
                if (%ssc_move(mDb.Channel,cursor,1)==SSQL_FAILURE)
                    ok = getDatabaseError("Failed to execute SQL statement")

            ;;Close the cursor
            closeCursor(cursor,ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Retrieves multiple rows from the Employee table in the database
        ;;; </summary>
        ;;; <param name="argWhere">WHERE clause to identify the rows to retrieve (don't include the WHERE keyword)</param>
        ;;; <param name="argRows">Collectio of returned rows</param>
        ;;; <returns>True for success, false for failure</returns>
        public method SelectRows, boolean
            required in  argWhere, string
            required out argRows,  @ArrayList
			endparams
			.include "CONNECTDIR:ssql.def"
            stack record local_data
                ok, boolean                             ;;OK to continue
                cursor, int                             ;;Database cursor
                recEmployee, strEmployee  ;;IO buffer
            endrecord
        proc

            argRows = new ArrayList()

            ;;Open a cursor for the SELECT statement
            if (^passed(argWhere) && argWhere.Length>0) then
                ok = openSelectCursor(mSelectAllStatement+" WHERE "+argWhere,cursor)
            else
                ok = openSelectCursor(mSelectAllStatement,cursor)

            ;;Prepare a structure definition to define where the data for each column
            ;;goes to within the record
            if (ok)
                ok = defineStructure(cursor,1,recordSpec,recEmployee)

            ;;Move data to host variables
            if (ok)
            begin
                repeat
                begin
                    using (%ssc_move(mDb.Channel,cursor,1)) select
                    (SSQL_NORMAL),
                        argRows.Add((@strEmployee)recEmployee)
                    (SSQL_NOMORE),
                        exitloop
                    (SSQL_FAILURE),
                    begin
                        ok = getDatabaseError("Failed to execute SQL statement")
                        exitloop
                    end
                    endusing
                end
            end

            ;;Close the cursor
            closeCursor(cursor,ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Deletes a row from the Employee table in the database
        ;;; </summary>
        ;;; <param name="argEmpId">Primary key segment EmpId</param>
        ;;; <returns>True for success, false for failure</returns>
        public method DeleteRow, boolean
            required in  argEmpId ,D6
			endparams
			.include "CONNECTDIR:ssql.def"
            stack record local_data
                ok          ,boolean    ;;Return status
                transaction ,boolean    ;;Transaction in progress
                cursor      ,int        ;;Database cursor
            endrecord
        proc

            init local_data
            ok = true

            ;;Start a database transaction
            if (ok = startTransaction())
                transaction = true

            ;;Open a cursor for the DELETE statement
            if (ok)
                if (%ssc_open(mDb.Channel,cursor,mDeleteByKeyStatement,SSQL_NONSEL,,1,argEmpId)==SSQL_FAILURE)
                    ok = getDatabaseError("Failed to open cursor")

            ;;Execute the query
            if (ok)
                ok = executeNonSelectCursor(cursor)

            ;;Close the cursor
            closeCursor(cursor,ok)

            ;;Commit or rollback the transaction
            if (transaction)
                ok = commitOrRollback(ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Deletes one or more rows from the Employee table in the
        ;;; database based on a WHERE clause expression.
        ;;; </summary>
        ;;; <param name="argWhere">
        ;;; WHERE clause to identify the rows to be deleted (don't include the
        ;;; WHERE keyword)
        ;;; </param>
        ;;; <returns>True for success, false for failure</returns>
        public method DeleteRows, boolean
            required in argWhere, string
            endparams
            stack record local_data
                ok          ,boolean    ;;Return status
                transaction ,boolean    ;;Transaction in progress
                cursor      ,int        ;;Database cursor
            endrecord
        proc

            init local_data
            ok = true

            ;;Start a database transaction
            if (ok = startTransaction())
                transaction = true

            ;;Open a cursor for the DELETE statement
            if (ok)
                ok = openNonSelectCursor("DELETE FROM Employee WHERE "+argWhere,cursor)

            ;;Execute the query
            if (ok)
                ok = executeNonSelectCursor(cursor)

            ;;Close the cursor
            closeCursor(cursor,ok)

            ;;Commit or rollback the transaction
            if (transaction)
                ok = commitOrRollback(ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Updates a row in the Employee in the database
        ;;; </summary>
        ;;; <param name="a_data">Record containing data to be updated</param>
        ;;; <returns>True if the row is updated, otherwise false</returns>
        public method UpdateRow, boolean
            required in  argEmployee, strEmployee
            endparams
            stack record local_data
                ok              ,boolean    ;;OK to continue
                transaction     ,boolean    ;;Transaction in progress
                cursor          ,int        ;;Database cursor
                sql             ,string     ;;SQL statement
                recEmployee, strEmployee
            endrecord
        proc

            init local_data
            ok = true

            ;;Load the data into the bound record
            recEmployee = argEmployee

            ;;Start a database transaction
            if (ok = startTransaction())
                transaction = true

            ;;Open a cursor for the UPDATE statement
            if (ok)
            begin
                sql = "UPDATE Employee SET "
                & "EmpId=:1,"
                & "EmpFirstName=:2,"
                & "EmpLastName=:3,"
                & "EmpDept=:4,"
                & "EmpHireDate=:5,"
                & "EmpPhone1=:6,"
                & "EmpPhone2=:7,"
                & "EmpPhone3=:8,"
                & "EmpPaid=:9,"
                & "EmpHomeOk=:10,"
                & "Noname001=:11"
                & " WHERE"
                & " EmpId='" + %atrim(^a(recEmployee.emp_id)) + "' "

                ok = openNonSelectCursor(sql,cursor)
            end

            ;;Prepare a structure definition to define where the data for each column
            ;;comes from within the record
            if (ok)
                ok = defineStructure(cursor,1,recordSpec,recEmployee)

            ;;Update the row in the database
            if (ok)
                ok = executeNonSelectCursor(cursor)

            ;;Close the cursor
            closeCursor(cursor,ok)

            ;;Commit or rollback the transaction
            if (transaction)
                ok = commitOrRollback(ok)

            mreturn ok

        endmethod

		;;; <summary>
		;;; Loads data from the file DAT:employee.ism into the Employee table in the database.
		;;; </summary>
		;;; <returns>True on successful load or false if an error occurred.</returns>
		public method Load, boolean
			endparams
			record 
				rows		,int
				failrows	,int
			endrecord
		proc
			mreturn Load(false,0,rows=0,failrows)
		endmethod

		;;; <summary>
		;;; Loads data from the file DAT:employee.ism into the Employee table in the database.
		;;; </summary>
		;;; <param name="a_logex">Whether to log exception records to a file.</param>
		;;; <returns>
		;;; True on successful load or false if an error occurred.
		;;; If exceptions are encountered but logged to a file then the return status will be true.
		;;; </returns>
		public method Load, boolean
			required in    a_logex      ,boolean
			endparams
			record 
				rows		,int
				failrows	,int
			endrecord
		proc
			mreturn Load(a_logex,0,rows=0,failrows)
		endmethod

		;;; <summary>
		;;; Loads data from the file DAT:employee.ism into the Employee table in the database.
		;;; </summary>
		;;; <param name="a_logchan">Open channel to log error messages to. Pass 0 to prevent logging.</param>
		;;; <param name="a_rows">Passed maximum number of rows to load, and returned number of rows successfully loaded</param>
		;;; <param name="a_failrows">Returned number of rows that failed to be inserted</param>
		;;; <returns>True on successful load or false if an error occurred.</returns>
		public method Load, boolean
			required in    a_logchan    ,int
			required inout a_rows       ,int
			required out   a_failrows   ,int
			endparams
		proc
			mreturn Load(false,a_logchan,a_rows,a_failrows)
		endmethod

		;;; <summary>
		;;; Loads data from the file DAT:employee.ism into the Employee table in the database.
		;;; </summary>
		;;; <param name="a_logex">Whether to log exception records to a file.</param>
		;;; <param name="a_logchan">Open channel to log error messages to. Pass 0 to prevent logging.</param>
		;;; <param name="a_rows">Passed maximum number of rows to load, and returned number of rows successfully loaded</param>
		;;; <param name="a_failrows">Returned number of rows that failed to be inserted</param>
		;;; <returns>True on successful load or false if an error occurred. If exceptions are encountered but logged to a file then the return status will be true.</returns>
		public method Load, boolean
			required in    a_logex      ,boolean
			required in    a_logchan    ,int
			required inout a_rows       ,int
			required out   a_failrows   ,int
			endparams
			.define BUFFER_ROWS 1000        ;;How manr rows load at once
			stack record local_data
				ok              ,boolean    ;;Return status
				filechn         ,int        ;;Data file channel
				ex_ch           ,int        ;;Exception log file channel
				maxrows         ,int        ;;Max rows to load (for testing)
				goodrows        ,int        ;;Rows successfully inserted
				failrows        ,int        ;;Rows that failed to insert
				rowData         ,@ArrayList ;;Row data to load
				exceptionRows   ,@ArrayList ;;Rows that failed to load
				recEmployee      , strEmployee
				objEmployee      , @strEmployee
			endrecord
		proc

			init local_data
			ok = true

			maxrows = a_rows

			;;Open the data file associated with the structure
			try
			begin
				open(filechn=%syn_freechn,i:i,"DAT:employee.ism")
			end
			catch (ex)
			begin
				ok = false
				mErrorMessage = "Failed to open file DAT:employee.ism. " + ex.Message
				clear filechn
			end
			endtry

			if (ok)
			begin
				data rowsLoaded, int, 0

				rowData = new ArrayList()

				;;Read records from the input file
				repeat
				begin
					;;Get the next record from the input file
					try
					begin
						reads(filechn,recEmployee)
					end
					catch (ex, @EndOfFileException)
					begin
						exitloop
					end
					endtry

					rowData.Add((@strEmployee)recEmployee)

					if ((maxrows)&&((rowsLoaded+=1)>=maxRows))
						exitloop

					;;If the buffer is full, write it to the database
					if (rowData.Count==BUFFER_ROWS)
						call insert_data

					if (!ok)
						exitloop
				end

				;;So we have any remaining records to insert?
				if (rowData.Count>0)
					call insert_data

				rowData = ^null

			end

			;;Close the file
			if (filechn)
				close filechn

			;;Close the exceptions log file
			if (ex_ch)
				close ex_ch

			;;Return number of rows inserted
			a_rows = goodrows

			;;Return number of failed rows
			a_failrows = failrows

			mreturn ok

		insert_data,

			if (this.InsertRows(rowData,exceptionRows,a_logchan))
			begin
				if (exceptionRows.Count==0) then
					goodrows += rowData.Count
				else
				begin
					;;Are we logging exceptions?
					if (a_logex) then
					begin
						;;Open the log file and log the exceptions
						if (!ex_ch)
							open(ex_ch=0,o:s,"Exceptions_Employee.log")
						foreach objEmployee in exceptionRows
							writes(ex_ch,(strEmployee)objEmployee)
						if (a_logchan)
							writes(a_logchan,"Exceptions were logged to Exceptions_Employee.log")
						;;Update the lobal counters
						goodrows += (rowData.Count-exceptionRows.Count)
						failrows += exceptionRows.Count
					end
					else
					begin
						;;No logging, report and error
						ok = false
					end
				end
			end

			exceptionRows = ^null
			rowData = new ArrayList()

			return

		endmethod

		;;; <summary>
		;;; Loads net change data from the file DAT:employee.ism into the Employee table in the database.
		;;; </summary>
		;;; <param name="a_logex">Whether to log exception records to a file.</param>
		;;; <param name="a_logchan">Open channel to log error messages to. Pass 0 to prevent logging.</param>
		;;; <param name="a_rows">Passed maximum number of rows to load, and returned number of rows successfully loaded</param>
		;;; <param name="a_failrows">Returned number of rows that failed to be inserted</param>
		;;; <returns>True on successful load or false if an error occurred. If exceptions are encountered but logged to a file then the return status will be true.</returns>
		public method LoadNetChange, boolean
			required in    a_logex      ,boolean
			required in    a_logchan    ,int
			required inout a_rows       ,int
			required out   a_failrows   ,int
			endparams
			.define BUFFER_ROWS 1000        ;;How manr rows load at once
			stack record local_data
				ok              ,boolean    ;;Return status
				filechn         ,int        ;;Data file channel
				ex_ch           ,int        ;;Exception log file channel
				maxrows         ,int        ;;Max rows to load (for testing)
				goodrows        ,int        ;;Rows successfully inserted
				failrows        ,int        ;;Rows that failed to insert
				rowData         ,@ArrayList ;;Row data to load
				exceptionRows   ,@ArrayList ;;Rows that failed to load
				recEmployee      , strEmployee
				objEmployee      , @strEmployee
			endrecord
		proc

			init local_data
			ok = true

			maxrows = a_rows

			;;Open the data file associated with the structure
			try
			begin
				open(filechn=%syn_freechn,i:i,"DAT:employee.ism")
			end
			catch (ex)
			begin
				ok = false
				mErrorMessage = "Failed to open file DAT:employee.ism. " + ex.Message
				clear filechn
			end
			endtry

			if (ok)
			begin
				data rowsLoaded, int, 0

				rowData = new ArrayList()

				;;Read records from the input file
				repeat
				begin
					;;Get the next record from the input file
					try
					begin
						reads(filechn,recEmployee)
					end
					catch (ex, @EndOfFileException)
					begin
						exitloop
					end
					endtry

					rowData.Add((@strEmployee)recEmployee)

					if ((maxrows)&&((rowsLoaded+=1)>=maxRows))
						exitloop

					;;If the buffer is full, write it to the database
					if (rowData.Count==BUFFER_ROWS)
						call insert_data

					if (!ok)
						exitloop
				end

				;;So we have any remaining records to insert?
				if (rowData.Count>0)
					call insert_data

				rowData = ^null

			end

			;;Close the file
			if (filechn)
				close filechn

			;;Close the exceptions log file
			if (ex_ch)
				close ex_ch

			;;Return number of rows inserted
			a_rows = goodrows

			;;Return number of failed rows
			a_failrows = failrows

			mreturn ok

		insert_data,

			if (this.InsertRows(rowData,exceptionRows,a_logchan))
			begin
				if (exceptionRows.Count==0) then
					goodrows += rowData.Count
				else
				begin
					;;Are we logging exceptions?
					if (a_logex) then
					begin
						;;Open the log file and log the exceptions
						if (!ex_ch)
							open(ex_ch=0,o:s,"Exceptions_Employee.log")
						foreach objEmployee in exceptionRows
							writes(ex_ch,(strEmployee)objEmployee)
						if (a_logchan)
							writes(a_logchan,"Exceptions were logged to Exceptions_Employee.log")
						;;Update the lobal counters
						goodrows += (rowData.Count-exceptionRows.Count)
						failrows += exceptionRows.Count
					end
					else
					begin
						;;No logging, report and error
						ok = false
					end
				end
			end

			exceptionRows = ^null
			rowData = new ArrayList()

			return

		endmethod

		;;; <summary>
        ;;; Cleans the data in a Employee record before it is inserted
        ;;; into the database.
        ;;; </summary>
        ;;; <param name="argCustomer">Employee record to be cleaned</param>
        private method cleanEmployeeData, void
            required inout argEmployee, strEmployee
            endparams
        proc
            if ((!argEmployee.emp_id)||(!this.IsNumeric(^a(argEmployee.emp_id))))
                clear argEmployee.emp_id
            if ((!argEmployee.emp_hire_date)||(!this.IsNumeric(^a(argEmployee.emp_hire_date))))
                ^a(argEmployee.emp_hire_date(1:1))=%char(0)
            if ((!argEmployee.emp_phone1)||(!this.IsNumeric(^a(argEmployee.emp_phone1))))
                clear argEmployee.emp_phone1
            if ((!argEmployee.emp_phone2)||(!this.IsNumeric(^a(argEmployee.emp_phone2))))
                clear argEmployee.emp_phone2
            if ((!argEmployee.emp_phone3)||(!this.IsNumeric(^a(argEmployee.emp_phone3))))
                clear argEmployee.emp_phone3
            if ((!argEmployee.emp_paid)||(!this.IsNumeric(^a(argEmployee.emp_paid))))
                clear argEmployee.emp_paid
            if ((!argEmployee.emp_home_ok)||(!this.IsNumeric(^a(argEmployee.emp_home_ok))))
                clear argEmployee.emp_home_ok
        endmethod

        ;;; <summary>
        ;;; Null terminate any empty alpha fields so that they show up as <NULL>
        ;;; in the database. By default SQL Connection inserts a single space.
        ;;; </summary>
        ;;; <param name="argEmployee">Employee record to be cleaned</param>
        private method nullTerminateEmptyAlphas, void
            required inout argEmployee, strEmployee
            endparams
        proc
            if(!argEmployee.emp_first_name)
                argEmployee.emp_first_name=%char(0)
            if(!argEmployee.emp_last_name)
                argEmployee.emp_last_name=%char(0)
            if(!argEmployee.emp_dept)
                argEmployee.emp_dept=%char(0)
            if(!argEmployee.noname_001)
                argEmployee.noname_001=%char(0)
        endmethod

        ;;; <summary>
        ;;; Loads field details into the recordSpec record
        ;;; </summary>
        private method loadRecordSpec, void
            endparams
        proc
            recordSpec.fieldCount = 11
            recordSpec.fields[1].fieldType     = "D" ;;EmpId
            recordSpec.fields[1].fieldSize     = 6
            recordSpec.fields[1].fieldDecimals = 0
            recordSpec.fields[2].fieldType     = "A" ;;EmpFirstName
            recordSpec.fields[2].fieldSize     = 30
            recordSpec.fields[2].fieldDecimals = 0
            recordSpec.fields[3].fieldType     = "A" ;;EmpLastName
            recordSpec.fields[3].fieldSize     = 30
            recordSpec.fields[3].fieldDecimals = 0
            recordSpec.fields[4].fieldType     = "A" ;;EmpDept
            recordSpec.fields[4].fieldSize     = 15
            recordSpec.fields[4].fieldDecimals = 0
            recordSpec.fields[5].fieldType     = "A" ;;EmpHireDate
            recordSpec.fields[5].fieldSize     = 8
            recordSpec.fields[5].fieldDecimals = 0
            recordSpec.fields[6].fieldType     = "D" ;;EmpPhone1
            recordSpec.fields[6].fieldSize     = 10
            recordSpec.fields[6].fieldDecimals = 0
            recordSpec.fields[7].fieldType     = "D" ;;EmpPhone2
            recordSpec.fields[7].fieldSize     = 10
            recordSpec.fields[7].fieldDecimals = 0
            recordSpec.fields[8].fieldType     = "D" ;;EmpPhone3
            recordSpec.fields[8].fieldSize     = 10
            recordSpec.fields[8].fieldDecimals = 0
            recordSpec.fields[9].fieldType     = "D" ;;EmpPaid
            recordSpec.fields[9].fieldSize     = 1
            recordSpec.fields[9].fieldDecimals = 0
            recordSpec.fields[10].fieldType     = "D" ;;EmpHomeOk
            recordSpec.fields[10].fieldSize     = 1
            recordSpec.fields[10].fieldDecimals = 0
            recordSpec.fields[11].fieldType     = "A" ;;Noname001
            recordSpec.fields[11].fieldSize     = 79
            recordSpec.fields[11].fieldDecimals = 0
        endmethod

        ;;; <summary>
        ;;; Loads various SQL statements into "shared" static variables
        ;;; </summary>
        private method loadSqlStatements, void
            endparams
        proc

            if (mCreateTableStatement==^null)
                mCreateTableStatement = "CREATE TABLE Employee ("
                & "EmpId DECIMAL(6) NOT NULL,"
                & "EmpFirstName VARCHAR(30) NOT NULL,"
                & "EmpLastName VARCHAR(30) NOT NULL,"
                & "EmpDept VARCHAR(15) NOT NULL,"
                & "EmpHireDate DATE,"
                & "EmpPhone1 DECIMAL(10),"
                & "EmpPhone2 DECIMAL(10),"
                & "EmpPhone3 DECIMAL(10),"
                & "EmpPaid DECIMAL(1),"
                & "EmpHomeOk DECIMAL(1),"
                & "Noname001 VARCHAR(79),"
                & "CONSTRAINT PK_Employee PRIMARY KEY CLUSTERED (EmpId ASC))"

            if (mInsertStatement==^null)
                mInsertStatement = "INSERT INTO Employee ("
                & "EmpId,"
                & "EmpFirstName,"
                & "EmpLastName,"
                & "EmpDept,"
                & "EmpHireDate,"
                & "EmpPhone1,"
                & "EmpPhone2,"
                & "EmpPhone3,"
                & "EmpPaid,"
                & "EmpHomeOk,"
                & "Noname001"
                & ") VALUES(:1,:2,:3,:4,:5,:6,:7,:8,:9,:10,:11)"

            if (mSelectByKeyStatement==^null)
                mSelectByKeyStatement = "SELECT "
                & "EmpId,"
                & "EmpFirstName,"
                & "EmpLastName,"
                & "EmpDept,"
                & "CONVERT(VARCHAR(8),EmpHireDate,112) AS [YYYYMMDD],"
                & "EmpPhone1,"
                & "EmpPhone2,"
                & "EmpPhone3,"
                & "EmpPaid,"
                & "EmpHomeOk,"
                & "Noname001"
                & " FROM Employee"
                & " WHERE  EmpId=:1 "

            if (mSelectAllStatement==^null)
                mSelectAllStatement = "SELECT "
                & "EmpId,"
                & "EmpFirstName,"
                & "EmpLastName,"
                & "EmpDept,"
                & "CONVERT(VARCHAR(8),EmpHireDate,112) AS [YYYYMMDD],"
                & "EmpPhone1,"
                & "EmpPhone2,"
                & "EmpPhone3,"
                & "EmpPaid,"
                & "EmpHomeOk,"
                & "Noname001"
                & " FROM Employee"

            if (mDeleteByKeyStatement==^null)
                mDeleteByKeyStatement = "DELETE FROM Employee WHERE  EmpId=:1 "

        endmethod

    endclass

    .ifndef strEmployee
    ;;Can't use a repository include when using SSQL_STRDEF because the FULL
    ;;record must be used, including the "NONAME_XXX" fields!
    structure strEmployee
        emp_id, d6
        emp_first_name, a30
        emp_last_name, a30
        emp_dept, a15
        emp_hire_date, d8
        emp_phone1, d10
        emp_phone2, d10
        emp_phone3, d10
        emp_paid, d1
        emp_home_ok, d1
        noname_001, a79
    endstructure
    .endc

endnamespace

