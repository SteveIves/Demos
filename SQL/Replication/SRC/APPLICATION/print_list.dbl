;*******************************************************************************
;
; Title:        print_list.dbl
;
; Description:  Print the contents of a Toolkit list using Print API
;
; Author:       Steve Ives
;
; Copyright:    ©Synergex International Inc.  All rights reserved.
;
; WARNING:      If you were given this code by a Synergex employee then you may
;               use and modify it freely for use with your own applications.
;               However, you may not under any circumstances distribute this
;               code, or any modified version of this code, to any third party
;               without first obtaining written permission to do so from
;               Synergex.  In using this code you accept that it is provided
;               as is, and without support or warranty.  Neither Synergex or the
;               author accept any responsibility for any losses or damages of
;               any nature which may arise from the use of this code.  This
;               header information must remain, unaltered, in the code at all
;               times.  Posession of this code, or any modified version of this
;               code, indicates your acceptance of these terms.
;
; $Revision: 1 $
;
; $Date: 2012-02-15 23:57:38-06:00 $
;
;*******************************************************************************
;
; Revision log:
;
; $History: /Demos/SQL/Replication/SRC/APPLICATION/print_list.dbl $
;; 
;; ****************** Version 1 ****************** 
;; User: Steve Ives   Date: 2012-02-15   Time: 23:57:38-06:00 
;; Updated in: /Demos/SQL/Replication/SRC/APPLICATION 
;; 
;; ****************** Version 1 ****************** 
;; User: Steve Ives   Date: 2009-03-01   Time: 19:25:58-08:00 
;; Updated in: /Development/Demos/Sql/Replication/SRC/TKLIB 
;
;*****************  Version 2  *****************
;User: Stevei       Date: 4/03/07    Time: 10:14a
;Updated in $/Synergy Projects/Code Generator/SUB
;Updated file header
;
;*******************************************************************************
;
.function print_list, ^VAL

	a_lstid			,n		; ID of list to print contents of
	a_lstdata		,a		; List non-window data record
	a_metafile		,a		; Metafile to create
	a_title			,a		; Print preview window title
	a_dialog		,n		; Display printer selection dialog?
	a_preview		,n		; Display print preview window?

.include "WND:tools.def"
.include "WND:windows.def"
.include "WND:system.def"
.include 'WND:setinf.def'
.include "WND:fldinf.def"
.include "DBLDIR:winprint.def"
.include "DBLDIR:activex.def"

external function
	tidy_string		,a

.align
stack record ivars

	; Error checking and return value
	ok				,i4		; OK to continue
	retval			,i4		; Return value

	; Local storage for optional parameters

	dialog			,i4		; Display printer selection dialog?
	preview			,i4		; Display print preview window?

	; Window ID's

	idi_detail		,i4		; Detail line item input window

	; Report counters

	page			,i4		; Current page number / number of pages printed
	row				,i4		; Row to print on
	record_count	,i4		; Number of records printed

	; Report, character and page dimensions

	report_cols		,i4		; Width required for report (width of input window)

	char_width		,i4		; Pixel width of a character
	char_height		,i4		; Pixel height of a character

	page_width		,i4		; Pixel width of the printable portion of the page
	page_height		,i4		; Pixel height of the printable portion of the page

	left_margin		,i4		; Pixel width of unprintable left margin
	top_margin		,i4		; Pixel height of unprintable top margin

	page_rows		,i4		; Number of rows that fit on a page
	page_cols		,i4		; Number of columns that fit on a page

	; Other local variables

	req				,i4		; List processor request flag
	atend			,i4		; Are we at the end of the list?
	control			,i4		; List ActiveX control ID

	rh				,i4		; report handle
	pen1			,i4		; Single pixel line pen
	print			,i4		; Print the report?
	count			,i4		; Generic for loop counter

	field_array		,i4		; Memory handle for array of field data

	x				,i4		; X position to print at
	y				,i4		; Y position to print at
	x2				,i4		; X position to end line at
	y2				,i4		; Y position to end line at

structure field
	name			,a32	; Field name
	length			,i4		; Display length
	col				,i4		; Column position in window
	pixel_position	,i4		; Pixel position in report
	heading			,a32	; Field heading

stack record avars
	databuf			,a256	; Data buffer for extracting report data from window

	; Font specifications

	fixedfont		,a^size(font_specs)
	propfont		,a^size(font_specs)
	propfont_bold	,a^size(font_specs)
	print_spec		,a^size(print_specs)

	; Pen specifications

	pixelpen		,a^size(pen_specs)

; Access report column x's pixel position (X)
.define fld_x_pos(x) left_margin + ^m(field[x].pixel_position,field_array)
; Access column x's pixel position (X)
.define col_x_pos(x) left_margin + (((x-1)*char_width)+1)
; Access row x's pixel position (Y)
.define row_y_pos(x) top_margin + (((x-1)*char_height)+1)
;
.define colhead(x) ^m(field[x].heading,field_array)
;
.define coldata(x) databuf(^m(field[x].col,field_array):^m(field[x].length,field_array))

.proc

	xcall e_enter

	clear avars, ^i(ivars)
	ok=TRUE

	; Make sure it's an ActivaX list
	xcall l_status(a_lstid,D_LACTIVEX,ok)
	if (!ok) then
		xcall u_msgbox("Can't print this list!",D_MOK+D_MICONEXCLAM,"Print Failed")
	else
		xcall l_status(a_lstid,D_LAXCTRL,control)

	if (ok)
	begin

		print = FALSE

		if (^passed(a_dialog).and.a_dialog) then
			dialog = 1
		else
			dialog = 0

		if (^passed(a_preview).and.a_preview) then
			preview = 1
		else
			preview = 0

		; Setup fixed-pitch font data
		^m(font_specs.facename, fixedfont) = "Courier New"
		^m(font_specs.pointsize, fixedfont) = 10
		^m(font_specs.weight, fixedfont) = DWPFW_NORMAL
		^m(font_specs.italic, fixedfont) = FALSE
		^m(font_specs.underline, fixedfont) = FALSE
		^m(font_specs.strikeout,fixedfont) = FALSE
		^m(font_specs.fixed, fixedfont) = TRUE

		; Setup variable-pitch font data
		propfont = fixedfont
		^m(font_specs.facename, propfont) = "Verdana"
		^m(font_specs.fixed, propfont) = FALSE

		; Setup bold variable-pitch font data
		propfont_bold = propfont
		^m(font_specs.weight, propfont_bold) = DWPFW_BOLD

		; Setup single pixel pen
		^m(pen_specs.pen_style, pixelpen)	= DWP_COSMETIC
		^m(pen_specs.line_style, pixelpen)	= DWP_SOLID
		^m(pen_specs.brush_color, pixelpen)	= M_RGB(0,0,0)

		; Get reference to list input window and find report width
		xcall l_status(a_lstid,D_LINPID,idi_detail)
		report_cols = %w_info(WIF_COLS,idi_detail)

		; Get report handle for default printer
		if (!%wpr_info(rh, DWP_GETPRINTER))
		begin
			ok = FALSE
			xcall u_msgbox("No printers available!",D_MICONEXCLAM,"Warning")
		end
	end

	; Display printer selection dialog if requested by program
	if (ok&&dialog)
	begin
		if(!%wpr_info(rh, DWP_PRINTDLG))
		begin
			; User selected cancel in the printer selection dialog
			xcall wpr_info(rh, DWP_DELPRINTER)
			retval = -1
			ok = FALSE
		end
	end

	; Set portrait mode and fixed font
	if (ok)
	begin
		xcall wpr_setdevice(rh, DWP_ORIENTATION, DWPO_PORTRAIT)
		xcall wpr_print(rh, DWP_BEGINJOB, a_metafile)
		xcall wpr_setdevice(rh, DWP_FONT, fixedfont)

		; Get character pixel dimensions
		char_width	= %wpr_info(rh,DWP_TEXTWIDTH)
		char_height	= %wpr_info(rh,DWP_TEXTHEIGHT)

		; Get page pixel dimensions
		xcall wpr_getdevice(rh,DWP_PIXELWIDTH,page_width)
		xcall wpr_getdevice(rh,DWP_PIXELHEIGHT,page_height)

		; Calculate page rows and columns in fixed-pitch font
		page_rows = page_height / char_height + 1
		page_cols = page_width  / char_width

		; Check if the report will fit in landscape mode
		if (report_cols>page_cols)
		begin
			; Try again, in landscape mode this time
			xcall wpr_print(rh, DWP_ENDJOB)
			xcall wpr_info(rh, DWP_DELPRINTER)
			xcall wpr_info(rh, DWP_GETPRINTER)
			xcall wpr_setdevice(rh, DWP_ORIENTATION, DWPO_LANDSCAPE)
			xcall wpr_print(rh, DWP_BEGINJOB, a_metafile)
			xcall wpr_setdevice(rh, DWP_FONT, fixedfont)

			; Get character pixel dimensions
			char_width	= %wpr_info(rh,DWP_TEXTWIDTH)
			char_height	= %wpr_info(rh,DWP_TEXTHEIGHT)

			; Get page pixel dimensions
			xcall wpr_getdevice(rh,DWP_PIXELWIDTH,page_width)
			xcall wpr_getdevice(rh,DWP_PIXELHEIGHT,page_height)

			; Calculate page rows and columns in fixed-pitch font
			page_rows = page_height / char_height + 1
			page_cols = page_width  / char_width

			if (report_cols>page_cols)
			begin
				; Report is too wide!
				xcall wpr_print(rh, DWP_ENDJOB)
				xcall wpr_info(rh, DWP_DELPRINTER)
				retval = -2
				ok = FALSE
			end

			; Get left and top margin pixels
			if (ok)
			begin
				xcall wpr_getdevice(rh,DWP_XOFFSET,left_margin)
				xcall wpr_getdevice(rh,DWP_YOFFSET,top_margin)
			end
		end

	end

	; Inspect the report detail window and get the column positions of each
	; field.  Then calculate the pixel position for each column.  We will use
	; this data to correctly position the column once we switch to a
	; proportional font.

	if (ok)
	begin

		; Get set info for the default set
		xcall i_setinf(idi_detail,,1,,gs_fldset)

		; Allocate memory for column positions
		field_array = %mem_proc(DM_ALLOC+DM_BLANK,^size(field) * gs_setcnt)

		; Iterate through set fields
		for count from 1 thru gs_setcnt
		begin

			; Get the field info
			xcall i_fldinf(idi_detail,^m(field[count].name,field_array),gs_setfldi(count),,gs_inpfld)
			^m(field[count].col,field_array) = gs_fcol
			^m(field[count].length,field_array) = gs_dsplen
			^m(field[count].pixel_position,field_array) = gs_fcol * char_width

			; Get column heading from ActiveX list
			xcall ax_call(control,"GetHeaderCell",count,^m(field[count].heading,field_array))

		end

		; Now proceed with a proportional font
		xcall wpr_setdevice(rh, DWP_FONT, propfont)

	end

	if (ok)
	begin

		; Position to first record in list
		xcall l_process(a_lstid,req=D_LTOP,a_lstdata)

		clear record_count, row, page

		xcall w_proc(WP_HOURGLASS_ON)
		xcall u_update
		xcall u_update(FALSE)

		; Iterate through the list, adding list rows to the print file

		repeat
		begin

			record_count+=1

			row+=1
			if (row>page_rows) || (record_count==1)
				call new_page

			; Retrieve text from list input window
			clear databuf
			xcall w_info(WI_XFR, idi_detail, WIX_DGET, databuf)

			; Print the row
			for count from 1 thru gs_setcnt
			begin
				x = fld_x_pos(count)
				y = row_y_pos(row)
				xcall wpr_print(rh,DWP_WRITEOUT,x,y,%tidy_string(coldata(count)))
			end

			; Are we at the bottom?
			xcall l_status(a_lstid,D_LATBOTTOM,atend)
			if (atend)
				exitloop

			; Position to first record in list
			xcall l_process(a_lstid,req=D_LDOWN,a_lstdata)

		end

		xcall w_proc(WP_HOURGLASS_OFF)
		xcall u_update(TRUE)

		if (record_count)
		begin

			print=TRUE

			; End print job
			xcall wpr_print(rh, DWP_ENDPAGE)
			xcall wpr_print(rh, DWP_ENDJOB)

			; Do print preview if required
			if (preview)
			begin

				if (%wpr_execute(rh,DWP_PREVIEW,a_metafile,%atrim(a_title),TRUE).eq.DWP_PREVIEW_CANCEL)
				begin
					; User selected cancel during print preview
					retval=-1
					print = FALSE
				end
			end

			; Do print if required
			if (print)
			begin
				if (.not.%wpr_execute(rh, DWP_PRINT,a_metafile))
					retval = -4 ; Print error
			end

		end

	end

	; Clean up

	if (rh)
        xcall wpr_info(rh, DWP_DELPRINTER)

	if (field_array)
		field_array = %mem_proc(DM_FREE,field_array)

	xcall e_exit

	freturn retval

;-------------------------------------------------------------------------------
;
new_page,

	pen1 = %wpr_info(rh,DWP_GETPEN,pixelpen)

	page+=1
	if (page>1)
		xcall wpr_print(rh,DWP_ENDPAGE)

	xcall wpr_print(rh,DWP_BEGINPAGE)

	; Activate bold font
	xcall wpr_setdevice(rh, DWP_FONT, propfont_bold)

	; Report title & page number

	row=1
	x = col_x_pos(1)
	y = row_y_pos(row)
	xcall wpr_print(rh,DWP_WRITEOUT,x,y,a_title)

	x = col_x_pos(page_cols-4-%trimz(%string(page)))
	y = row_y_pos(row)
	xcall wpr_print(rh,DWP_WRITEOUT,x,y,"Page " + %string(page))

	; Line above column headings

	row = 2
	x = col_x_pos(1)
	x2 = x + page_width
	y = row_y_pos(row) + (char_height/2)
	xcall wpr_print(rh,DWP_LINE,pen1,x,y,x2,y)

	; Column headings

	row=3
	for count from 1 thru gs_setcnt
	begin
		x = fld_x_pos(count)
		y = row_y_pos(row)
		xcall wpr_print(rh,DWP_WRITEOUT,x,y,colhead(count))
	end

	; Draw a line below the column headings

	row = 4
	x = col_x_pos(1)
	x2 = x + page_width
	y = row_y_pos(row) + (char_height/2)
	xcall wpr_print(rh,DWP_LINE,pen1,x,y,x2,y)

	; Back to non-bold font
	xcall wpr_setdevice(rh, DWP_FONT, propfont)

	; Set row for first report line

	row=5

	xcall wpr_info(rh,DWP_DELPEN,pen1)

	return

.end

