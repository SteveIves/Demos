;;*****************************************************************************
;;
;; Routine:     employee_io
;;
;; Author:      Steve Ives
;;
;; Company:     Synergex
;;
;; Created:     02/15/2012 at 23:35
;;
;;*****************************************************************************
;;
;; WARNING:     This code was generated by CodeGen V4.0.2.  Any changes that
;;              you make to this file will be lost if the code is regenerated.
;;
;;*****************************************************************************
;;
function employee_io ,^val

    required in    a_mode       ,n  ;;Access type
    required inout a_channel    ,n  ;;Channel
    required in    a_key        ,a  ;;Key value
    required in    a_keynum     ,n  ;;Key number
    .include "EMPLOYEE" repository, required inout group="employee"
    optional in    a_lock       ,n  ;;If passed and TRUE, lock record
    optional in    a_partial    ,n  ;;Do a partial key lookup
    optional out   a_errtxt     ,a  ;;Returned error text
    endparams

    .include "GENSRC:StructureIO.def"

    stack record localData
        err                 ,int    ;;Error occurred / error number
        line                ,int    ;;Error line number
        keyno               ,int    ;;Key number
        keylen              ,int    ;;Key length
        lock                ,int    ;;Lock record?
        pos                 ,int    ;;Position in a string
        errmsg              ,a45    ;;Error message
        message             ,a80    ;;User message
        keyval              ,a255   ;;Hold original key
        .include "EMPLOYEE" repository, group="tmp_employee"
    endrecord

    ;.define TAG_FIELD     No tag exists for this structure
    ;.define TAG_VALUE     ""
    ;.define TAG_ENDVALUE  ""

proc

    init localData

    onerror fatalIoError

    if ^passed(a_key)
    begin
        keyval = a_key
        if (^passed(a_partial)&&a_partial) then
            keylen = %trim(a_key)
        else
            keylen = ^size(a_key)
    end

    if ^passed(a_keynum) then
        keyno=a_keynum
    else
        keyno=D_PRIMKEY

    if (!^passed(a_key) && ^passed(employee))
    begin
        keyval = %keyval(a_channel,employee,keyno)
        if (^passed(a_partial)&&a_partial) then
            keylen = %trim(%keyval(a_channel,employee,keyno))
        else
            keylen = ^len(%keyval(a_channel,employee,keyno))
    end

    if (!^passed(a_lock)) then
        lock = Q_NO_LOCK
    else
        lock = Q_AUTO_LOCK

    if (^passed(a_errtxt))
        clear a_errtxt

    using a_mode select

    (IO_OPEN_INP),
    begin
        open(a_channel=%syn_freechn,i:i,"DAT:EMPLOYEE.ISM")
        &   [ERR=openError]
    end

    (IO_OPEN_UPD),
    begin
        open(a_channel=%syn_freechn,u:i,"DAT:EMPLOYEE.ISM")
        &   [ERR=openError]
        xcall ChannelCacheInit(a_channel)
    end

    (IO_FIND),
    begin
        find(a_channel,,keyval(1:keylen),KEYNUM:keyno)
        &   [$ERR_EOF=endOfFile,$ERR_LOCKED=recordLocked,$ERR_KEYNOT=keyNotFound]
    end

    (IO_FIND_FIRST),
    begin
        find(a_channel,,^FIRST,KEYNUM:keyno)
        &   [$ERR_EOF=endOfFile,$ERR_LOCKED=recordLocked,$ERR_KEYNOT=keyNotFound]
    end

    (IO_READ_FIRST),
    begin
        .ifdef TAG_FIELD
        read(a_channel,employee,TAG_VALUE,KEYNUM:keyno,LOCK:lock)
        &   [$ERR_EOF=endOfFile,$ERR_LOCKED=recordLocked,$ERR_KEYNOT=keyNotFound]
        .else
        read(a_channel,employee,^FIRST,KEYNUM:keyno,LOCK:lock)
        &   [$ERR_EOF=endOfFile,$ERR_LOCKED=recordLocked,$ERR_KEYNOT=keyNotFound]
        .endc
        if (lock==Q_AUTO_LOCK)
            xcall ChannelCacheUpdate(a_channel,employee)
    end

    (IO_READ),
    begin
        read(a_channel,employee,keyval(1:keylen),KEYNUM:keyno,LOCK:lock)
        &   [$ERR_EOF=endOfFile,$ERR_LOCKED=recordLocked,$ERR_KEYNOT=keyNotFound]
        if (lock==Q_AUTO_LOCK)
            xcall ChannelCacheUpdate(a_channel,employee)
    end

    (IO_READ_NEXT),
    begin
        reads(a_channel,employee,LOCK:lock)
        &   [$ERR_EOF=endOfFile,$ERR_LOCKED=recordLocked,$ERR_KEYNOT=keyNotFound]
        if (lock==Q_AUTO_LOCK)
            xcall ChannelCacheUpdate(a_channel,employee)
    end

    (IO_READ_PREV),
    begin
        reads(a_channel, employee,,REVERSE,LOCK:lock)
        &   [$ERR_EOF=endOfFile,$ERR_LOCKED=recordLocked,$ERR_KEYNOT=keyNotFound]
        if (lock==Q_AUTO_LOCK)
            xcall ChannelCacheUpdate(a_channel,employee)
    end

    (IO_READ_LAST),
    begin
        .ifdef TAG_FIELD
        begin
            read(a_channel,employee,TAG_ENDVALUE,KEYNUM:keyno,LOCK:lock)
            &   [$ERR_EOF=readLastTag,$ERR_LOCKED=recordLocked,$ERR_KEYNOT=readLastTag]
            ;;Now read the perious one!
            if (FALSE) then
readLastTag,    read(a_channel,employee,^LAST,KEYNUM:keyno,LOCK:lock)
                &   [$ERR_EOF=endOfFile,$ERR_LOCKED=recordLocked,$ERR_KEYNOT=keyNotFound]
            else
                reads(a_channel,employee,,REVERSE,LOCK:lock)
                &   [$ERR_EOF=endOfFile,$ERR_LOCKED=recordLocked,$ERR_KEYNOT=keyNotFound]
        end
        .else
        read(a_channel,employee,^LAST, KEYNUM:keyno,LOCK:lock)
        &   [$ERR_EOF=endOfFile,$ERR_LOCKED=recordLocked,$ERR_KEYNOT=keyNotFound]
        .endc
        if (lock==Q_AUTO_LOCK)
            xcall ChannelCacheUpdate(a_channel,employee)
    end

    (IO_CREATE),
    begin
        .ifdef TAG_FIELD
        employee.TAG_FIELD = TAG_VALUE
        .endc
        ;;Make sure zero decimals contain zeros not spaces
        if (!employee.emp_id)
            clear employee.emp_id
        if (!employee.emp_hire_date)
            clear employee.emp_hire_date
        if (!employee.emp_phone[1])
            clear employee.emp_phone[1]
        if (!employee.emp_phone[2])
            clear employee.emp_phone[2]
        if (!employee.emp_phone[3])
            clear employee.emp_phone[3]
        if (!employee.emp_paid)
            clear employee.emp_paid
        if (!employee.emp_home_ok)
            clear employee.emp_home_ok
		;;Populate the replication key field with a unique value
		employee.replication_key = %datetime
		;;Store the new record
        store(a_channel,employee)
        &   [$ERR_NODUPS=duplicateKey]
        xcall replicate(REPLICATION_INSTRUCTION.CREATE_ROW,
        &   'EMPLOYEE',employee.replication_key)
    end

    (IO_DELETE),
    begin
        delete(a_channel)
        &   [$ERR_NOCURR=noCurrentRecord]
        xcall ChannelCacheRetrieve(a_channel,tmp_employee)
        xcall replicate(REPLICATION_INSTRUCTION.DELETE_ROW,
        &   'EMPLOYEE',tmp_employee.replication_key)
    end

    (IO_UPDATE),
    begin
        write(a_channel,employee)
        &   [$ERR_NOCURR=noCurrentRecord]
        if (%ChannelCacheCompare(a_channel,employee))
            xcall replicate(REPLICATION_INSTRUCTION.UPDATE_ROW,
            &   'EMPLOYEE',employee.replication_key)
    end

    (IO_UNLOCK),
    begin
        unlock a_channel
    end

    (IO_CLOSE),
    begin
        if (a_channel)
        begin
            close a_channel
            clear a_channel
        end
        end

    (IO_READ_SQL),
    begin
        read(a_channel,employee,keyval(1:keylen),KEYNUM:"REPLICATION_KEY")
        &   [$ERR_EOF=endOfFile,$ERR_KEYNOT=keyNotFound]
    end

    (),
    begin
        if (^passed(a_errtxt))
            a_errtxt = "Invalid file access mode"
    end

    endusing

    offerror

    ;;If we have a tag, chek it here
    .ifdef TAG_FIELD
    if (^passed(employee))
    begin
        if (^a(employee.TAG_FIELD)!=TAG_VALUE)
        begin
            if (!^passed(a_lock) || (^passed(a_lock) && !a_lock))
                if (a_channel && %chopen(a_channel))
                    unlock a_channel
            freturn IO_EOF
        end
    end
    .endc

    if (!^passed(a_lock) || (^passed(a_lock) && !a_lock))
        if (a_channel && %chopen(a_channel))
            unlock a_channel

    freturn IO_OK

;;-----------------------------------------------------------------------------

recordLocked,

    ;;Return the locked error code
    if (^passed(a_errtxt))
        a_errtxt = "Record locked"

    freturn IO_LOCKED

;;-----------------------------------------------------------------------------

endOfFile,

    unlock a_channel

    if (^passed(a_errtxt))
        a_errtxt = "Record not found - end of file"

    freturn IO_EOF

;;-----------------------------------------------------------------------------

keyNotFound,

    unlock a_channel

    if (^passed(a_errtxt))
        a_errtxt = "Record not found"

    freturn IO_NOT_FOUND

;;-------------------------------------------------------------------------------

duplicateKey,

    unlock a_channel

    if (^passed(a_errtxt))
        a_errtxt = "Record already exists"

    freturn IO_DUP_KEY

;;-----------------------------------------------------------------------------

noCurrentRecord,

    unlock a_channel

    if (^passed(a_errtxt))
        a_errtxt = "No record was locked"

    freturn IO_NO_CUR_REC

;;-----------------------------------------------------------------------------

fatalIoError,

    if (a_channel && %chopen(a_channel))
        unlock a_channel

    offerror

    if (^passed(a_errtxt))
    begin
        call getErrorText
        a_errtxt = message
    end

    freturn IO_FATAL

;;-----------------------------------------------------------------------------

getErrorText,

    xcall error(err,line)
    xcall ertxt(err,errmsg)

    xcall s_bld(message,,'Error : %d, %a, at line : %d',err,errmsg,line)

    return


;;-----------------------------------------------------------------------------

openError,

    if (^passed(a_errtxt))
        a_errtxt = "Failed to open file"

    freturn IO_FATAL

endfunction

function employee_length ,^val
    endparams
proc
    freturn 200
endfunction


