;;*****************************************************************************
;;
;; Program:     ReverseReplicator
;;
;; Desctiption: This program replicates changes in one or more SQL Server
;;              tables to associated Synergy data files.
;;
;; Author:      Steve Ives
;;              Synergex Professional Services Group
;;
;; Company:     Synergex
;;
;;***********************************************************************************

main ReverseReplicator

    .define DB_CONSTR "VTX12_SQLNATIVE://SqlReverseReplication/.\\SQLEXPRESS///Trusted_connection=yes"

    .include "CONNECTDIR:ssql.def"
    .include "DBLDIR:namspc.def"
    .include "SRC:StructureIO.def"
    .include "TO_REPLICATE" repository, record="instruction", end

    .define D_MAX_CUR       20
    .define D_MAX_COL       200
    .define D_MAX_BUFFER    4096

    .define D_SLEEP_TIME    5                   ;;Seconds to hibernate if nothing to do

    .define log(x)          writes(logch,%atrim(x))
    .define debuglog(x)     if (fullLogging) writes(logch,x)

    global common
        db                  ,i4                 ;;Database channel
        nsid                ,i4                 ;;Name space id
        logch               ,i4                 ;;Log file channel
        inserts             ,i4                 ;;Number of create operations completed
        updates             ,i4                 ;;Number of update operations completed
        deletes             ,i4                 ;;Number of delete operations completed
        fails               ,i4                 ;;Number of failed operations
    endcommon

    record local_data
        sleep_time          ,i4                 ;;Seconds to sleep
        error               ,i4                 ;;Error occured
        abort               ,boolean            ;;Fatal error occurred
        dberr               ,i4                 ;;Database error
        length              ,i4                 ;;Length of buffer
        status              ,i4                 ;;General working status return
        fullLogging         ,boolean            ;;Are we doing full logging?
        function_name       ,a40                ;;External function to call
        log_file            ,a256
        log_mode            ,a3
        databuffer          ,a(D_MAX_BUFFER)
        tempbuffer          ,a(D_MAX_BUFFER)
        dberrtxt            ,a1024
        shutdownCommand     ,a3

        missingTableAbort   ,boolean
        missingFileAbort    ,boolean
        insertFailedAbort   ,boolean
        updateFailedAbort   ,boolean
        deleteFailedAbort   ,boolean

    endrecord

    record table
        name                ,a30                ;;Name of structure
        file_channel        ,i4                 ;;ISAM channel being used
        record_length       ,i4                 ;;Record length
    endrecord

    external function
        xsubr               ,^val
    endexternal

proc

    init local_data
    xcall flags(7004020,1)

    ;;Are we running on a terminal?
    if (%tnmbr>=0) then
    begin
        log_file = "tt:"
        log_mode = "o"
    end
    else
    begin
        ;;Do we have a log file specified?
        xcall getlog("REVERSE_REPLICATOR_LOGFILE",databuffer,length)
        if (length) then
        begin
            ;;Yes - use it
            log_file = databuffer
        end
        else
        begin
            ;;No - create one in the current directory
            log_file = "REVERSE_REPLICATOR.LOG"
        end
        log_mode = "o:s"
    end

    sleep_time = D_SLEEP_TIME
    xcall getlog("REVERSE_REPLICATOR_INTERVAL",databuffer,length)
    if ((length>0)&& %IsNumeric(%atrim(databuffer)))
        sleep_time = %integer(%atrim(databuffer))

    xcall getlog("REVERSE_REPLICATOR_FULL_LOG",databuffer,length)
    if ((length>0)&&(databuffer.eq."YES"))
        fullLogging = 1

    ;;Open the log file
    try
    begin
        open(logch=0,log_mode,log_file)
    end
    catch (ex)
    begin
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE,"Reverse replicator failed to open log file " + %atrim(log_file)+". Error number " + %string(%ernum))
        error=1
    end
    endtry

    if (!error)
    begin
        missingTableAbort   = true
        missingFileAbort    = true
        insertFailedAbort   = true
        updateFailedAbort   = true
        deleteFailedAbort   = true
    end

    if (!error)
    begin
        log("SQL Reverse Replicator Log")
        log("Sleep interval is " + %string(sleep_time) + " seconds.")
    end

    ;;Enable and Initialize SQL Connection
    if (!error)
    begin
        .ifdef OS_VMS
        xcall init_ssql
        .else
        status=%option(48,1)
        .endc
        if (%ssc_init(db=1,D_MAX_CUR,D_MAX_COL,D_MAX_BUFFER)==SSQL_FAILURE)
        begin
            log("ERROR: Failed to initialize SQL Connection")
            error=1
        end
    end

    ;;Connect to the database
    if (!error)
    begin
        if (%ssc_connect(db,DB_CONSTR)==SSQL_NORMAL) then
            debuglog("Connected to database")
        else
        begin
            xcall ssc_getemsg(db,dberrtxt,length)
            log("ERROR: Failed to connect to SQL Server")
            log("Connect string: " + DB_CONSTR)
            log("Error message : " + dberrtxt(1,length))
            error=1
        end
    end

    ;;Make sure the replication instructions table is present
    if ((!error)&&(!%ToReplicateExists(db,dberrtxt)>0))
    begin
        log("ERROR: Table 'ToReplicate' was not found. " + %atrim(dberrtxt))
        error = 1
    end

    ;;Main processing
    if (!error)
    begin
        ;;Create a namespace to record information about Synergy data files that we have opened.
        nsid = %nspc_open(,%size(table))

        log("Processing instructions")

        ;;Main loop
        repeat
        begin
            clear error

            ;;Do we have any replication instructions?
            if (!%ToReplicateFirstId(db,instruction.audit_log_id)) then
            begin
                ;;Serious failure
            end
            else
            begin
                if (instruction.audit_log_id) then
                begin
                    ;;There is a replication instruction out there

                    ;;Retrieve it
                    if (!%ToReplicateSelectRow(db,instruction.audit_log_id,instruction)) then
                    begin
                        ;;Failed to retrieve instruction
                        ;TODO: What now?
                    end
                    else
                    begin
                        debuglog("Found instruction "+%string(instruction.audit_log_id)+": " + instruction.change_type + " for table " + %atrim(instruction.table_name))

                        ;;Make sure we have the Synergy data file open
                        call CheckSynergyFile
                        if (abort)
                            exitloop

                        ;;Get the data for the row from the database
                        ;;(not for DELETE, all we need is the GUID)
                        if (!error)
                        begin
                            if (instruction.change_type!="DELETE")
                            begin
                                call GetDatabaseRow
                                if (abort)
                                    exitloop
                            end
                        end

                        ;;Execute the instruction
                        if (!error)
                        begin
                            using (instruction.change_type) select
                            ("INSERT"),
                                call DoInsert
                            ("UPDATE"),
                                call DoUpdate
                            ("DELETE"),
                                call DoDelete
                            endusing
                            if (abort)
                                exitloop
                        end

                        ;;Delete the replication instruction from the database
                        ;;We'll try to do this even if we had an error that we
                        ;;are contunuing from, because if we leave don't then
                        ;;we'll just wind up processing the same instruction
                        ;;over and over!
                        if (!ToReplicateDeleteRow(db,instruction.audit_log_id))
                        begin
                            log("ERROR: Failed to delete instruction "+%string(instruction.audit_log_id)+" from database")
                            error = 1
                            ;;If we fail to delete an instruction then we MUST
                            ;;abort, otherwisw we'll wind up processing the same
                            ;;thing over and over!
                            exitloop
                        end
                    end
                end
                else
                begin
                    ;;No outstanding instructions, check for instruction to exit
                    xcall getlog("REVERSE_REPLICATOR_SHUTDOWN",shutdownCommand="",length)
                    if ((length==3)&&(shutdownCommand=="YES"))
                    begin
                        xcall ReplicatorShutdown
                        stop
                    end
                    ;;If no shutdown, sleep a while
                    sleep sleep_time
                end
            end

        end ;of main processing loop
    end

    ;;Close the database
    if (db)
        xcall ssc_release(db)

    ;;Release the name space.
   if (nsid)
       xcall nspc_close(nsid)

    ;;If logging to tt: then pause so messages can be read
    if (log_file == "tt:")
    begin
        display(logch,"Press a key: ")
        accept(logch,log_file)
    end

    ;;We're done
    stop

;;-----------------------------------------------------------------------------
;; Do we already have the data file associated with the current replication
;; instruction open? This routine will also validate that the table exists in\
;; the database.
;;
CheckSynergyFile,

    ;;Do we already have the file open?
    if (!%nspc_find(nsid,instruction.table_name,table))
    begin
        ;;No, first make sure the table exists in the database
        call CheckDatabaseTable
        if (error)
            exit

        ;;Open the file and make sure it worked
        call OpenFile
        if (error)
            exit

        ;;Get the record size of the file
        function_name = %atrim(instruction.table_name)+"_length"

        try
        begin
            table.record_length = %xsubr(function_name)

            ;;Save the structure name
            table.name = instruction.table_name

            ;;Record the new open file in the namespace
            nspc_add(nsid,instruction.table_name,table)

            debuglog("Opened file for table "+%atrim(instruction.table_name))

        end
        catch (ex, @SynException)
        begin
            error = ex.Errno
            log("ERROR: Error " + %string(error) + " calling %" + %atrim(function_name) + ", message was " + ex.Message)
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------
;; Verify that the table associated with the current replication instruction
;; exists in the database.
;;
CheckDatabaseTable,

    function_name = %atrim(instruction.table_name)+"Exists"

    try
    begin
        if (!%xsubr(function_name,db,dberrtxt))
        begin
            error = 1
            log("ERROR: Table %" + %atrim(instruction.table_name) + " not found in database.")
            log("       Message: " + %atrim(dberrtxt))
        end
    end
    catch (ex, @SynException)
    begin
        error = ex.Errno
        log("ERROR: Error " + %string(error) + " calling %" + %atrim(function_name) + ", message was " + ex.Message)
    end
    endtry

    abort = (error&&missingTableAbort)

    return

;;-----------------------------------------------------------------------------
;; Open the data file associated with the current replication instruction.
;;
OpenFile,

    function_name = %atrim(instruction.table_name)+"_io"

    try
    begin
        status=%xsubr(function_name,IO_OPEN_UPD,table.file_channel,,,,,,dberrtxt)
        if (status!=IO_OK)
        begin
            error = 1
            log("ERROR: %" + %atrim(function_name) + " failed with status " + %string(status) + " " + %atrim(dberrtxt))
        end
    end
    catch (ex, @SynException)
    begin
        error = ex.Errno
        log("ERROR: Error " + %string(error) + " calling %" + %atrim(function_name) + ", message was " + ex.Message)
    end
    endtry

    abort = (error&&missingFileAbort)

    return

;;-----------------------------------------------------------------------------
;; Retrieve the row associated with the current replication instruction from
;; the database. This routine is not called for DELETE instructions.
;;
GetDatabaseRow,

    function_name = %atrim(instruction.table_name) + "SelectRow"

    try
    begin
        ;;This could fail if we're reading for an insert or update and there
        ;;has been a subsequent delete!!!
        if (!%xsubr(function_name,db,instruction.row_guid,databuffer(1,table.record_length),dberrtxt))
            log("ERROR: %" + %atrim(function_name) + " failed. " + %atrim(dberrtxt))
    end
    catch (ex, @SynException)
    begin
        error = ex.Errno
        log("ERROR: Error " + %string(error) + " calling %" + %atrim(function_name) + ", message was " + ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Add a new record to the file associated with the current replication instruction.
;;
DoInsert,

    function_name = %atrim(instruction.table_name) + '_io'

    try
    begin
        if (%xsubr(function_name,IO_CREATE,table.file_channel,,,databuffer(1,table.record_length),,,dberrtxt)==IO_OK) then
        begin
            debuglog("Created record " + %keyval(table.file_channel,databuffer(1,table.record_length),0) + " in file " + %atrim(instruction.table_name))
            inserts += 1
        end
        else
        begin
            error = 1
            log("ERROR: Failed to create record in file " + %atrim(instruction.table_name))
            log("       Message     : " + %atrim(dberrtxt))
            log("       Row GUID    : " + %atrim(instruction.row_guid))
            log("       Primary key : " + %keyval(table.file_channel,databuffer(1,table.record_length),0))
            fails += 1
        end
    end
    catch (ex, @SynException)
    begin
        error = ex.Errno
        log("ERROR: Error " + %string(error) + " calling %" + %atrim(function_name) + ", message was " + ex.Message)
        fails += 1
    end
    endtry

    abort = (error&&insertFailedAbort)

    return

;;-----------------------------------------------------------------------------
;; Update a record in the file associated with the current replication instruction.
;;
DoUpdate,

    function_name = %atrim(instruction.table_name) + '_io'

    try
    begin
        ;;Read and lock the existing record
        if (%xsubr(function_name,IO_READ_SQL,table.file_channel,instruction.row_guid,,tempbuffer(1,table.record_length),true,,dberrtxt)==IO_OK) then
        begin
            ;;Update the record
            if (%xsubr(function_name,IO_UPDATE,table.file_channel,,,databuffer(1,table.record_length),,,dberrtxt)==IO_OK) then
            begin
                debuglog("Updated record " + %keyval(table.file_channel,databuffer(1,table.record_length),0) + " in file " + %atrim(instruction.table_name))
                updates += 1
            end
            else
            begin
                error = 1
                log("ERROR: Failed to update record in file " + %atrim(instruction.table_name))
                log("       Message     : " + %atrim(dberrtxt))
                log("       Row GUID    : " + %atrim(instruction.row_guid))
                log("       Primary key : " + %keyval(table.file_channel,databuffer(1,table.record_length),0))
                fails += 1
            end
        end
        else
        begin
            error = 1
            log("ERROR: Failed to lock record in file " + %atrim(instruction.table_name))
            log("       Message     : " + %atrim(dberrtxt))
            log("       Row GUID    : " + %atrim(instruction.row_guid))
            log("       Primary key : " + %keyval(table.file_channel,databuffer(1,table.record_length),0))
            fails += 1
        end
    end
    catch (ex, @SynException)
    begin
        error = ex.Errno
        log("ERROR: Error " + %string(error) + " calling %" + %atrim(function_name) + ", message was " + ex.Message)
    end
    endtry

    abort = (error&&updateFailedAbort)

    return

;;-----------------------------------------------------------------------------
;; Delete a record from the file associated with the current replication instruction.
;;
DoDelete,

    function_name = %atrim(instruction.table_name) + '_io'

    try
    begin
        ;;Read and lock the existing record
        if (%xsubr(function_name,IO_READ_SQL,table.file_channel,instruction.row_guid,,tempbuffer(1,table.record_length),true,,dberrtxt)==IO_OK) then
        begin
            ;;Delete the record
            if (%xsubr(function_name,IO_DELETE,table.file_channel,,,,,,dberrtxt)==IO_OK) then
            begin
                debuglog("Deleted record " + %keyval(table.file_channel,databuffer(1,table.record_length),0) + " from file " + %atrim(instruction.table_name))
                deletes += 1
            end
            else
            begin
                error = 1
                log("ERROR: Failed to delete record from file " + %atrim(instruction.table_name))
                log("       Message     : " + %atrim(dberrtxt))
                log("       Row GUID    : " + %atrim(instruction.row_guid))
                log("       Primary key : " + %keyval(table.file_channel,databuffer(1,table.record_length),0))
                fails += 1
            end
        end
        else
        begin
            error = 1
            log("ERROR: Failed to lock record in file " + %atrim(instruction.table_name))
            log("       Message     : " + %atrim(dberrtxt))
            log("       Row GUID    : " + %atrim(instruction.row_guid))
            log("       Primary key : " + %keyval(table.file_channel,databuffer(1,table.record_length),0))
            fails += 1
        end
    end
    catch (ex, @SynException)
    begin
        error = ex.Errno
        log("ERROR: Error " + %string(error) + " calling %" + %atrim(function_name) + ", message was " + ex.Message)
        fails += 1
    end
    endtry

    abort = (error&&deleteFailedAbort)

    return

endmain

;;*****************************************************************************
;;
;; Routine:     ReplicatorShutdown
;;
;; Description: This routine is an event handler which is called when the
;;              replicator service is being stopped by the Windows operating
;;              system.
;;
;; Author:      Steve Ives
;;
;; Company:     Synergex
;;
;; Created:     04/10/2008 at 22:17
;;
;;*****************************************************************************
;;
;; This code is supplied as seen and without warranty or support, and is used
;; at your own risk. Neither the author or Synergex accept any responsability
;; for any loss or damage which may result from the use of this code. This text
;; must remain unaltered in this file at all times. Possession or use of this
;; code, or any modified version of this code, indicates your acceptance of
;; these conditions.
;;
;;*****************************************************************************
;;
subroutine ReplicatorShutdown

    endparams

    .include "CONNECTDIR:ssql.def"
    .include "DBLDIR:namspc.def"
    .include "SRC:StructureIO.def"

    external common
        db              ,i4         ;;Database channel
        nsid            ,i4         ;;Name space id
        logch           ,i4         ;;Log file channel
        inserts         ,i4         ;;Number of create operations completed
        updates         ,i4         ;;Number of update operations completed
        deletes         ,i4         ;;Number of delete operations completed
        fails           ,i4         ;;Number of failed operations
    endcommon

    stack record
        idx             ,i4         ;;Loop counter
        access_code     ,i4         ;;Namespace access code
        status          ,i4         ;;Function return status
        function_name   ,a40        ;;External function name to call
    endrecord

    record table
        name            ,a30        ;;Name of structure
        file_channel    ,i4         ;;ISAM channel being used
        record_length   ,i4         ;;Record length
    endrecord

proc

    log("------------------------------------------------------------")
    log("Reverse replicator shutdown requested. Session summary:")
    log("INSERTS: " + %string(inserts,"ZZZ,ZZZ,ZZZ,ZZX"))
    log("UPDATES: " + %string(updates,"ZZZ,ZZZ,ZZZ,ZZX"))
    log("DELETES: " + %string(deletes,"ZZZ,ZZZ,ZZZ,ZZX"))
    log("ERRORS:  " + %string(fails,  "ZZZ,ZZZ,ZZZ,ZZX"))
    log("------------------------------------------------------------")

    ;;Close the database
    if (db)
    begin
        xcall ssc_release(db)
        clear db
    end

    ;;Close any data files that we have open
    if (nsid)
    begin
        for idx from 1 thru %nspc_stoa(nsid,9999)
        begin
            ;;Get the item data from the namespace
            access_code = %nspc_stoa(nsid,idx)
            xcall nspc_getdata(nsid,access_code,table)
            ;;Close the channel
            if ((table.file_channel)&&%chopen(table.file_channel))
            begin
                function_name = %atrim(table.name)+"_io"
                try
                begin
                    xsubr(function_name,IO_CLOSE,table.file_channel)
                end
                catch (ex)
                begin
                    nop
                end
                endtry
            end
        end

        xcall nspc_close(nsid)
        clear nsid

    end

    xreturn

endsubroutine

