;;*****************************************************************************
;;
;; Title:       CustomerTable.dbl
;;
;; Type:        Class
;;
;; Description: This class provides the ability to interact with a SQL Server
;;              database table named Customer using records defined
;;              by the repository structure CUSTOMER, with underlying
;;              (mapped) records defined by the structure CUSMAS
;;              and data stored in the file DAT:cusmas.ism.
;;
;; Author:      "Steve Ives"
;;
;; Company:     "Synergex Professional Services Group"
;;
;;*****************************************************************************
;;
;; WARNING:     This code was generated by CodeGen. Any changes that you make
;;              to this file will be lost if the code is regenerated.
;;
;;*****************************************************************************
;;
import System.Collections
import SqlUploadDemo

namespace SqlUploadDemo

    .ifndef strCustomer
    .include "CUSTOMER" repository, public structure="strCustomer", end
    .endc

    .ifndef strCUSMAS
    .include "CUSMAS" repository, public structure="strCUSMAS", end
    .endc

    ;;; <summary>
    ;;; Class used to interact with the database table Customer
    ;;; </summary>
    public class CustomerTable extends DatabaseTableBase

        ;;SQL Statements
        private static mCreateTableStatement    ,string
        private static mInsertStatement         ,string
        private static mSelectByKeyStatement    ,string
        private static mSelectAllStatement      ,string
        private static mSelectWhereStatement    ,string
        private static mDeleteByKeyStatement    ,string

        ;;Defines the layout of the synergy record used to transfer data
        ;;to and from the database. Used with %ssc_strdef() and populated
        ;;by the loadRecordSpec() method which is called from the constructor
        private record recordSpec
            fieldCount          ,d3
            group fields        ,[21]a
                fieldType       ,a1         ;Field type (A/D/I)
                fieldSize       ,d5         ;Field length
                fieldDecimals   ,d2         ;Implied decimal places (for D)
            endgroup
        endrecord

        ;;; <summary>
        ;;; Constructor
        ;;; </summary>
        ;;; <param name="aDb">DatabaseConnection object</returns>
        public method CustomerTable
            required in aDb, @DatabaseConnection
            endparams
            parent(aDb)
        proc
            loadRecordSpec()
            loadSqlStatements()
        endmethod

        ;;; <summary>
        ;;; Create a Customer table in the database
        ;;; </summary>
        ;;; <returns>True for success, false for failure</returns>
        public method Create, boolean
            endparams
            stack record local_data
                ok          ,boolean    ;;Return status
                cursor      ,int        ;;Database cursor
                transaction ,boolean    ;;Transaction in process
            endrecord
        proc
            init local_data
            ok = true

            ;;Start a new transaction
            if (ok = startTransaction())
                transaction = true

            ;;Create the database table and primary key
            if (ok)
            begin
                if (ok=openNonSelectCursor(mCreateTableStatement,cursor))
                begin
                    ok = executeNonSelectCursor(cursor)
                    closeCursor(cursor,ok)
                end
            end

            ;;Create index 1 (Company name)
            if (ok)
            begin
                if (ok=openNonSelectCursor("CREATE  INDEX IX_Customer_Company ON Customer(Company ASC)",cursor))
                begin
                    ok = executeNonSelectCursor(cursor)
                    closeCursor(cursor,ok)
                end
            end

            ;;Create index 2 (State)
            if (ok)
            begin
                if (ok=openNonSelectCursor("CREATE  INDEX IX_Customer_State ON Customer(State ASC)",cursor))
                begin
                    ok = executeNonSelectCursor(cursor)
                    closeCursor(cursor,ok)
                end
            end

            ;;Create index 3 (Zip code)
            if (ok)
            begin
                if (ok=openNonSelectCursor("CREATE  INDEX IX_Customer_Zip ON Customer(Zip ASC)",cursor))
                begin
                    ok = executeNonSelectCursor(cursor)
                    closeCursor(cursor,ok)
                end
            end

            ;;Create index 4 (Account status)
            if (ok)
            begin
                if (ok=openNonSelectCursor("CREATE  INDEX IX_Customer_Status ON Customer(Status ASC)",cursor))
                begin
                    ok = executeNonSelectCursor(cursor)
                    closeCursor(cursor,ok)
                end
            end

            ;;Grant access permissions
            if (ok&&(ok=openNonSelectCursor("GRANT ALL ON Customer TO PUBLIC",cursor)))
            begin
                ok = executeNonSelectCursor(cursor)
                closeCursor(cursor,ok)
            end

            ;;Commit or rollback the transaction
            if (transaction)
                ok = commitOrRollback(ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Deletes the Customer table from the database
        ;;; </summary>
        ;;; <returns>True for success, false for failure</returns>
        public method Drop, boolean
            endparams
            .include "CONNECTDIR:ssql.def"
            stack record local_data
                ok          ,boolean    ;;Return status
                cursor      ,int        ;;Database cursor
                transaction ,boolean    ;;Transaction in progress
            endrecord
        proc

            init local_data
            ok = true

            ;;Start a database transaction
            if (ok = startTransaction())
                transaction = true

            ;;Open cursor for DROP TABLE statement
            ;;
            if (ok)
                ok=openNonSelectCursor("DROP TABLE Customer",cursor)

            ;;Execute DROP TABLE statement
            ;;
            if (ok)
            begin
                if (!(ok = executeNonSelectCursor(cursor)))
                begin
                    data dbErrText, a1024
                    data length, int
                    if (%ssc_getemsg(mDb.Channel,dbErrText,length,,mErrorNumber)==SSQL_NORMAL)
                    begin
                        ;;Check if the error was that the table did not exist
                        if (mErrorNumber==-3701) then
                        begin
                            clear mErrorMessage
                            ok = true
                        end
                        else
                            mErrorMessage = atrim(dbErrText)
                    end
                end
            end

            ;;Close the cursor
            closeCursor(cursor,ok)

            ;;Commit or rollback the transaction
            if (transaction)
                ok = commitOrRollback(ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Deletes all data from the Customer table in the database
        ;;; </summary>
        ;;; <returns>True for success, false for failure</returns>
        public method Clear, boolean
            endparams
            stack record local_data
                ok          ,boolean    ;;Return status
                cursor      ,int        ;;Database cursor
                transaction ,boolean    ;;Transaction in process
            endrecord
        proc

            init local_data
            ok = true

            ;;Start a database transaction
            if (ok = startTransaction())
                transaction = true

            ;;Open cursor for the SQL statement
            if (ok)
                ok = openNonSelectCursor("TRUNCATE TABLE Customer",cursor)

            ;;Execute SQL statement
            if (ok)
                ok = executeNonSelectCursor(cursor)

            ;;Close the cursor
            closeCursor(cursor,ok)

            ;;Commit or rollback the transaction
            if (transaction)
                ok = commitOrRollback(ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Checks if the Customer table exists in the database
        ;;; </summary>
        ;;; <returns>True if the table exists, false if not (or an error occurred)</returns>
        public method Exists, boolean
            endparams
            .include "CONNECTDIR:ssql.def"
            .include "CUSTOMER" repository, stack record="customer"
            stack record local_data
                ok          ,boolean    ;;Return value
                cursor      ,int        ;;Database cursor
                table_name  ,a128       ;;Retrieved table name
            endrecord
        proc

            init customer,local_data

            ;;Open a cursor for the SELECT statement
            ;;
            ok = openSelectCursor("SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='Customer'",cursor)

            ;;Bind host variables to receive the data
            if (ok)
                if (%ssc_define(mDb.Channel,cursor,1,table_name)==SSQL_FAILURE)
                    ok = getDatabaseError("Failed to bind variable")

            ;;Move data to host variables
            if (ok)
                if (%ssc_move(mDb.Channel,cursor,1)==SSQL_FAILURE)
                    ok = false

            ;;Close the cursor
            closeCursor(cursor,ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Inserts a new row into the Customer table in the database
        ;;; </summary>
        ;;; <param name="argCustomer">Record containing data to insert</param>
        ;;; <returns>True for success, false for failure</returns>
        public method InsertRow, boolean
            required in argCustomer, strCustomer
            endparams
            stack record local_data
                ok              ,boolean    ;;Return status
                cursor          ,int        ;;Database cursor
                transaction     ,boolean    ;;Transaction in progress
                recCustomer, strCustomer
            endrecord
        proc

            init local_data
            ok = true

            ;;Start a database transaction
            if (ok = startTransaction())
                transaction = true

            ;;Open a cursor for the INSERT statement
            if (ok)
                ok = openNonSelectCursor(mInsertStatement,cursor)

            ;;Prepare a structure definition to define where the data for each column
            ;;comes from within the record
            ;;
            if (ok)
                ok = defineStructure(cursor,1,recordSpec,recCustomer)

            ;;Insert the row into the database
            if (ok)
            begin
                ;;Load the data into our local buffer
                recCustomer = argCustomer

                ;;If requested, clean the data
                if (mCleanData)
                    cleanCustomerData(recCustomer)

                ;;If requested, null terminate empty alpha fields
                if (mEmptyAlphaNull)
                    nullTerminateEmptyAlphas(recCustomer)

                ;;Execute the INSERT statement
                ok = executeNonSelectCursor(cursor)
            end

            ;;Close the cursor
            closeCursor(cursor,ok)

            ;;Commit or rollback the transaction
            if (transaction)
                ok = commitOrRollback(ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Inserts multiple new rows into the Customer table in the database.
        ;;; </summary>
        ;;; <param name="argRecords">Collection of any number of boxed Customer records to insert.</param>
        ;;; <returns>True for success, false for failure.</returns>
        public method InsertRows        ,boolean
            required in  argRecords     ,@ArrayList
            endparams
        proc
            mreturn doInsertRows(argRecords,^null,0)
        endmethod

        ;;; <summary>
        ;;; Inserts multiple new rows into the Customer table in the database
        ;;; and returns a collection containing the data for any rows that failed to
        ;;; insert.
        ;;; </summary>
        ;;; <param name="argRecords">Collection of any number of boxed Customer records to insert.</param>
        ;;; <param name="argExceptions">Collection of records that failed to insert.</param>
        ;;; <returns>True for success, false for failure.</returns>
        public method InsertRows        ,boolean
            required in  argRecords     ,@ArrayList
            required out argExceptions  ,@ArrayList
            endparams
        proc
            if (argExceptions==^null)
                argExceptions = new ArrayList()
            mreturn doInsertRows(argRecords,argExceptions,0)
        endmethod

        ;;; <summary>
        ;;; Inserts multiple new rows into the Customer table in the database
        ;;; and logs any errors to a supplied log channel.
        ;;; </summary>
        ;;; <param name="argRecords">Collection of any number of boxed Customer records to insert.</param>
        ;;; <param name="argLogCh">Channel to log error messages to.</param>
        ;;; <returns>True for success, false for failure.</returns>
        public method InsertRows        ,boolean
            required in argRecords      ,@ArrayList
            required in argLogCh        ,i
            endparams
        proc
            mreturn doInsertRows(argRecords,^null,argLogCh)
        endmethod

        ;;; <summary>
        ;;; Inserts multiple new rows into the Customer table in the database,
        ;;; returns a collection containing the data for any rows that failed to
        ;;; insert, and also logs errors to s supplied log channel.
        ;;; </summary>
        ;;; <param name="argRecords">Collection of any number of boxed Customer records to insert.</param>
        ;;; <param name="argExceptions">Collection of records that failed to inserted.</param>
        ;;; <param name="argLogCh">Channel to log error messages to.</param>
        ;;; <returns>True for success, false for failure.</returns>
        public method InsertRows        ,boolean
            required in  argRecords     ,@ArrayList
            required out argExceptions  ,@ArrayList
            required in  argLogCh       ,i
            endparams
        proc
            if (argExceptions==^null)
                argExceptions = new ArrayList()
            mreturn doInsertRows(argRecords,argExceptions,argLogCh)
        endmethod

        private method doInsertRows     ,boolean
            required in argRecords      ,@ArrayList
            required in argExceptions   ,@ArrayList
            required in argLogCh        ,i
            endparams
            stack record local_data
                ok          ,boolean    ;;Return status
                cursor      ,int        ;;Database cursor
                transaction ,boolean    ;;Transaction in progress
                continue    ,int        ;;Continue after an error
                recCustomer, strCustomer
                objCustomer, @strCustomer
            endrecord
        proc

            init local_data
            ok = true

            ;;Start a database transaction
            if (ok = startTransaction())
                transaction = true

            ;;Open a cursor for the INSERT statement
            if (ok)
                ok = openNonSelectCursor(mInsertStatement,cursor)

            ;;Prepare a structure definition to define where the data for each column
            ;;comes from within the record
            if (ok)
                ok = defineStructure(cursor,1,recordSpec,recCustomer)

            ;;Insert the rows into the database
            if (ok)
            begin
                data cnt, int
                foreach objCustomer in argRecords
                begin
                    ;;Load data into the bound record
                    recCustomer = (strCustomer)objCustomer

                    ;;If requested, clean the data
                    if (mCleanData)
                        cleanCustomerData(recCustomer)

                    ;;If requested, null terminate empty alpha fields
                    if (mEmptyAlphaNull)
                        nullTerminateEmptyAlphas(recCustomer)

                    ;;Execute the INSERT statement
                    if (!(ok = executeNonSelectCursor(cursor)))
                    begin
                        ;;We got an error, lets decide what to do with it
                        clear continue

                        ;;Are we logging errors?
                        if (argLogCh)
                        begin
                            writes(argLogCh,mErrorMessage)
                            continue=1
                        end

                        ;;Are we processing exceptions?
                        if (argExceptions!=^null)
                        begin
                            argExceptions.Add((@strCustomer)recCustomer)
                            continue=1
                        end

                        if (continue)
                        begin
                            ok = true
                            nextloop
                        end

                        exitloop
                    end
                end
            end

            ;;Close the cursor
            closeCursor(cursor,ok)

            ;;Commit or rollback the transaction
            if (transaction)
                ok = commitOrRollback(ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Retrieves a row from the Customer table in the database
        ;;; </summary>
        ;;; <param name="argAccount">Primary key segment account</param>
        ;;; <param name="argCustomer">Customer record to return data in</param>
        ;;; <returns>True for success, false for failure</returns>
        public method SelectRow, boolean
            required in  argAccount, a
            required out argCustomer, strCustomer
            endparams
            .include "CONNECTDIR:ssql.def"
            stack record local_data
                ok              ,boolean    ;;OK to continue
                cursor          ,int        ;;Database cursor
            endrecord
        proc

            ok = true

            ;;Open a cursor for the SELECT statement
            if (%ssc_open(mDb.Channel,cursor,mSelectByKeyStatement,SSQL_SELECT,,1,argAccount)==SSQL_FAILURE)
                ok = getDatabaseError("Failed to open cursor")

            ;;Prepare a structure definition to define where the data for each column
            ;;goes to within the record
            if (ok)
                ok = defineStructure(cursor,1,recordSpec,argCustomer)

            ;;Move data to host variables
            if (ok)
                if (%ssc_move(mDb.Channel,cursor,1)==SSQL_FAILURE)
                    ok = getDatabaseError("Failed to execute SQL statement")

            ;;Close the cursor
            closeCursor(cursor,ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Retrieves multiple rows from the Customer table in the database
        ;;; </summary>
        ;;; <param name="argWhere">WHERE clause to identify the rows to retrieve (don't include the WHERE keyword)</param>
        ;;; <param name="argRows">Collectio of returned rows</param>
        ;;; <returns>True for success, false for failure</returns>
        public method SelectRows, boolean
            required in  argWhere, string
            required out argRows,  @ArrayList
            endparams
            .include "CONNECTDIR:ssql.def"
            stack record local_data
                ok, boolean                             ;;OK to continue
                cursor, int                             ;;Database cursor
                recCustomer, strCustomer  ;;IO buffer
            endrecord
        proc

            argRows = new ArrayList()

            ;;Open a cursor for the SELECT statement
            if (^passed(argWhere) && argWhere.Length>0) then
                ok = openSelectCursor(mSelectAllStatement+" WHERE "+argWhere,cursor)
            else
                ok = openSelectCursor(mSelectAllStatement,cursor)

            ;;Prepare a structure definition to define where the data for each column
            ;;goes to within the record
            if (ok)
                ok = defineStructure(cursor,1,recordSpec,recCustomer)

            ;;Move data to host variables
            if (ok)
            begin
                repeat
                begin
                    using (%ssc_move(mDb.Channel,cursor,1)) select
                    (SSQL_NORMAL),
                        argRows.Add((@strCustomer)recCustomer)
                    (SSQL_NOMORE),
                        exitloop
                    (SSQL_FAILURE),
                    begin
                        ok = getDatabaseError("Failed to execute SQL statement")
                        exitloop
                    end
                    endusing
                end
            end

            ;;Close the cursor
            closeCursor(cursor,ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Deletes a row from the Customer table in the database
        ;;; </summary>
        ;;; <param name="argAccount">Primary key segment Account</param>
        ;;; <returns>True for success, false for failure</returns>
        public method DeleteRow, boolean
            required in  argAccount ,a
            endparams
            .include "CONNECTDIR:ssql.def"
            stack record local_data
                ok          ,boolean    ;;Return status
                transaction ,boolean    ;;Transaction in progress
                cursor      ,int        ;;Database cursor
            endrecord
        proc

            init local_data
            ok = true

            ;;Start a database transaction
            if (ok = startTransaction())
                transaction = true

            ;;Open a cursor for the DELETE statement
            if (ok)
                if (%ssc_open(mDb.Channel,cursor,mDeleteByKeyStatement,SSQL_NONSEL,,1,argAccount)==SSQL_FAILURE)
                    ok = getDatabaseError("Failed to open cursor")

            ;;Execute the query
            if (ok)
                ok = executeNonSelectCursor(cursor)

            ;;Close the cursor
            closeCursor(cursor,ok)

            ;;Commit or rollback the transaction
            if (transaction)
                ok = commitOrRollback(ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Deletes one or more rows from the Customer table in the
        ;;; database based on a WHERE clause expression.
        ;;; </summary>
        ;;; <param name="argWhere">
        ;;; WHERE clause to identify the rows to be deleted (don't include the
        ;;; WHERE keyword)
        ;;; </param>
        ;;; <returns>True for success, false for failure</returns>
        public method DeleteRows, boolean
            required in argWhere, string
            endparams
            stack record local_data
                ok          ,boolean    ;;Return status
                transaction ,boolean    ;;Transaction in progress
                cursor      ,int        ;;Database cursor
            endrecord
        proc

            init local_data
            ok = true

            ;;Start a database transaction
            if (ok = startTransaction())
                transaction = true

            ;;Open a cursor for the DELETE statement
            if (ok)
                ok = openNonSelectCursor("DELETE FROM Customer WHERE "+argWhere,cursor)

            ;;Execute the query
            if (ok)
                ok = executeNonSelectCursor(cursor)

            ;;Close the cursor
            closeCursor(cursor,ok)

            ;;Commit or rollback the transaction
            if (transaction)
                ok = commitOrRollback(ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Updates a row in the Customer in the database
        ;;; </summary>
        ;;; <param name="a_data">Record containing data to be updated</param>
        ;;; <returns>True if the row is updated, otherwise false</returns>
        public method UpdateRow, boolean
            required in  argCustomer, strCustomer
            endparams
            stack record local_data
                ok              ,boolean    ;;OK to continue
                transaction     ,boolean    ;;Transaction in progress
                cursor          ,int        ;;Database cursor
                sql             ,string     ;;SQL statement
                recCustomer, strCustomer
            endrecord
        proc

            init local_data
            ok = true

            ;;Load the data into the bound record
            recCustomer = argCustomer

            ;;Start a database transaction
            if (ok = startTransaction())
                transaction = true

            ;;Open a cursor for the UPDATE statement
            if (ok)
            begin
                sql = "UPDATE Customer SET "
                & "Account=:1,"
                & "Company=:2,"
                & "Street=:3,"
                & "City=:4,"
                & "State=:5,"
                & "Zip=:6,"
                & "PhoneNumber=:7,"
                & "FaxNumber=:8,"
                & "MobileNumber=:9,"
                & "PagerNumber=:10,"
                & "Email1=:11,"
                & "Email2=:12,"
                & "DateOpened=:13,"
                & "DateHold=:14,"
                & "DateClosed=:15,"
                & "Status=:16,"
                & "Limit=:17,"
                & "Balance=:18,"
                & "CardNumber=:19,"
                & "CardExpiry=:20,"
                & "CardName=:21"
                & " WHERE"
                & " Account='" + %atrim(^a(recCustomer.account)) + "' "

                ok = openNonSelectCursor(sql,cursor)
            end

            ;;Prepare a structure definition to define where the data for each column
            ;;comes from within the record
            if (ok)
                ok = defineStructure(cursor,1,recordSpec,recCustomer)

            ;;Update the row in the database
            if (ok)
                ok = executeNonSelectCursor(cursor)

            ;;Close the cursor
            closeCursor(cursor,ok)

            ;;Commit or rollback the transaction
            if (transaction)
                ok = commitOrRollback(ok)

            mreturn ok

        endmethod

        ;;; <summary>
        ;;; Loads data from the file DAT:cusmas.ism into the Customer table in the database.
        ;;; </summary>
        ;;; <returns>True on successful load or false if an error occurred.</returns>
        public method Load, boolean
            endparams
            record
                rows        ,int
                failrows    ,int
            endrecord
        proc
            mreturn Load(false,0,rows=0,failrows)
        endmethod

        ;;; <summary>
        ;;; Loads data from the file DAT:cusmas.ism into the Customer table in the database.
        ;;; </summary>
        ;;; <param name="a_logex">Whether to log exception records to a file.</param>
        ;;; <returns>
        ;;; True on successful load or false if an error occurred.
        ;;; If exceptions are encountered but logged to a file then the return status will be true.
        ;;; </returns>
        public method Load, boolean
            required in    a_logex      ,boolean
            endparams
            record
                rows        ,int
                failrows    ,int
            endrecord
        proc
            mreturn Load(a_logex,0,rows=0,failrows)
        endmethod

        ;;; <summary>
        ;;; Loads data from the file DAT:cusmas.ism into the Customer table in the database.
        ;;; </summary>
        ;;; <param name="a_logchan">Open channel to log error messages to. Pass 0 to prevent logging.</param>
        ;;; <param name="a_rows">Passed maximum number of rows to load, and returned number of rows successfully loaded</param>
        ;;; <param name="a_failrows">Returned number of rows that failed to be inserted</param>
        ;;; <returns>True on successful load or false if an error occurred.</returns>
        public method Load, boolean
            required in    a_logchan    ,int
            required inout a_rows       ,int
            required out   a_failrows   ,int
            endparams
        proc
            mreturn Load(false,a_logchan,a_rows,a_failrows)
        endmethod

        ;;; <summary>
        ;;; Loads data from the file DAT:cusmas.ism into the Customer table in the database.
        ;;; </summary>
        ;;; <param name="a_logex">Whether to log exception records to a file.</param>
        ;;; <param name="a_logchan">Open channel to log error messages to. Pass 0 to prevent logging.</param>
        ;;; <param name="a_rows">Passed maximum number of rows to load, and returned number of rows successfully loaded</param>
        ;;; <param name="a_failrows">Returned number of rows that failed to be inserted</param>
        ;;; <returns>True on successful load or false if an error occurred. If exceptions are encountered but logged to a file then the return status will be true.</returns>
        public method Load, boolean
            required in    a_logex      ,boolean
            required in    a_logchan    ,int
            required inout a_rows       ,int
            required out   a_failrows   ,int
            endparams
            .define BUFFER_ROWS 1000        ;;How manr rows load at once
            stack record local_data
                ok              ,boolean    ;;Return status
                filechn         ,int        ;;Data file channel
                ex_ch           ,int        ;;Exception log file channel
                maxrows         ,int        ;;Max rows to load (for testing)
                goodrows        ,int        ;;Rows successfully inserted
                failrows        ,int        ;;Rows that failed to insert
                rowData         ,@ArrayList ;;Row data to load
                exceptionRows   ,@ArrayList ;;Rows that failed to load
                recCUSMAS   , strCUSMAS
                recCustomer      , strCustomer
                objCustomer      , @strCustomer
            endrecord
        proc

            init local_data
            ok = true

            maxrows = a_rows

            ;;Open the data file associated with the mapped structure
            try
            begin
                open(filechn=%syn_freechn,i:i,"DAT:cusmas.ism")
            end
            catch (ex)
            begin
                ok = false
                mErrorMessage = "Failed to open file DAT:cusmas.ism. " + ex.Message
                clear filechn
            end
            endtry

            if (ok)
            begin
                data rowsLoaded, int, 0

                rowData = new ArrayList()

                ;;Read records from the input file
                repeat
                begin
                    ;;Get the next record from the input file
                    try
                    begin
                        reads(filechn,recCUSMAS)
                    end
                    catch (ex, @EndOfFileException)
                    begin
                        exitloop
                    end
                    endtry

                    ;;Map the data into the next database record
                    this.Map(recCUSMAS,recCustomer)
                    rowData.Add((@strCustomer)recCustomer)

                    if ((maxrows)&&((rowsLoaded+=1)>=maxRows))
                        exitloop

                    ;;If the buffer is full, write it to the database
                    if (rowData.Count==BUFFER_ROWS)
                        call insert_data

                    if (!ok)
                        exitloop
                end

                ;;So we have any remaining records to insert?
                if (rowData.Count>0)
                    call insert_data

                rowData = ^null

            end

            ;;Close the file
            if (filechn)
                close filechn

            ;;Close the exceptions log file
            if (ex_ch)
                close ex_ch

            ;;Return number of rows inserted
            a_rows = goodrows

            ;;Return number of failed rows
            a_failrows = failrows

            mreturn ok

        insert_data,

            if (this.InsertRows(rowData,exceptionRows,a_logchan))
            begin
                if (exceptionRows.Count==0) then
                    goodrows += rowData.Count
                else
                begin
                    ;;Are we logging exceptions?
                    if (a_logex) then
                    begin
                        ;;Open the log file and log the exceptions
                        if (!ex_ch)
                            open(ex_ch=0,o:s,"Exceptions_Customer.log")
                        foreach objCustomer in exceptionRows
                            writes(ex_ch,(strCustomer)objCustomer)
                        if (a_logchan)
                            writes(a_logchan,"Exceptions were logged to Exceptions_Customer.log")
                        ;;Update the lobal counters
                        goodrows += (rowData.Count-exceptionRows.Count)
                        failrows += exceptionRows.Count
                    end
                    else
                    begin
                        ;;No logging, report and error
                        ok = false
                    end
                end
            end

            exceptionRows = ^null
            rowData = new ArrayList()

            return

        endmethod

        ;;; <summary>
        ;;; Cleans the data in a Customer record before it is inserted
        ;;; into the database.
        ;;; </summary>
        ;;; <param name="argCustomer">Customer record to be cleaned</param>
        private method cleanCustomerData, void
            required inout argCustomer, strCustomer
            endparams
        proc
            if ((!argCustomer.zip)||(!this.IsNumeric(^a(argCustomer.zip))))
                clear argCustomer.zip
            if ((!argCustomer.phone_number)||(!this.IsNumeric(^a(argCustomer.phone_number))))
                clear argCustomer.phone_number
            if ((!argCustomer.fax_number)||(!this.IsNumeric(^a(argCustomer.fax_number))))
                clear argCustomer.fax_number
            if ((!argCustomer.mobile_number)||(!this.IsNumeric(^a(argCustomer.mobile_number))))
                clear argCustomer.mobile_number
            if ((!argCustomer.pager_number)||(!this.IsNumeric(^a(argCustomer.pager_number))))
                clear argCustomer.pager_number
            if ((!argCustomer.date_opened)||(!this.IsDate(argCustomer.date_opened)))
                ^a(argCustomer.date_opened(1:1))=%char(0)
            if ((!argCustomer.date_hold)||(!this.IsDate(argCustomer.date_hold)))
                ^a(argCustomer.date_hold(1:1))=%char(0)
            if ((!argCustomer.date_closed)||(!this.IsDate(argCustomer.date_closed)))
                ^a(argCustomer.date_closed(1:1))=%char(0)
            if ((!argCustomer.status)||(!this.IsNumeric(^a(argCustomer.status))))
                clear argCustomer.status
            if ((!argCustomer.limit)||(!this.IsNumeric(^a(argCustomer.limit))))
                clear argCustomer.limit
            if ((!argCustomer.balance)||(!this.IsNumeric(^a(argCustomer.balance))))
                clear argCustomer.balance
            if ((!argCustomer.card_expiry)||(!this.IsNumeric(^a(argCustomer.card_expiry))))
                clear argCustomer.card_expiry
        endmethod

        ;;; <summary>
        ;;; Null terminate any empty alpha fields so that they show up as <NULL>
        ;;; in the database. By default SQL Connection inserts a single space.
        ;;; </summary>
        ;;; <param name="argCustomer">Customer record to be cleaned</param>
        private method nullTerminateEmptyAlphas, void
            required inout argCustomer, strCustomer
            endparams
        proc
            if(!argCustomer.account)
                argCustomer.account(1:1)=%char(0)
            if(!argCustomer.company)
                argCustomer.company(1:1)=%char(0)
            if(!argCustomer.street)
                argCustomer.street(1:1)=%char(0)
            if(!argCustomer.city)
                argCustomer.city(1:1)=%char(0)
            if(!argCustomer.state)
                argCustomer.state(1:1)=%char(0)
            if(!argCustomer.email1)
                argCustomer.email1(1:1)=%char(0)
            if(!argCustomer.email2)
                argCustomer.email2(1:1)=%char(0)
            if(!argCustomer.card_number)
                argCustomer.card_number(1:1)=%char(0)
            if(!argCustomer.card_name)
                argCustomer.card_name(1:1)=%char(0)
        endmethod

        ;;; <summary>
        ;;; Maps a CUSMAS record into a CUSTOMER record
        ;;; </summary>
        ;;; <param name="ctmst">Passed CUSMAS record</param>
        ;;; <param name="customer">Returned CUSTOMER record</param>
        public method Map, void
            required in  cusmas, strCUSMAS
            required out customer, strCustomer
            endparams
        proc
            customer.account = cusmas.cusacc
            customer.company = cusmas.cusnam
            customer.street = cusmas.cusad1
            customer.city = cusmas.cusad2
            customer.state = cusmas.cusad3
            customer.zip = cusmas.cusad4
            customer.phone_number = cusmas.cuspno
            customer.fax_number = cusmas.cusfno
            customer.mobile_number = cusmas.cusmno
            customer.pager_number = cusmas.cuspgn
            customer.email1 = cusmas.cusem1
            customer.email2 = cusmas.cusem2
            customer.date_opened = cusmas.cusdao
            customer.date_hold = cusmas.cusdah
            customer.date_closed = cusmas.cusdac
            customer.status = cusmas.cusast
            customer.limit = cusmas.cusclm
            customer.balance = cusmas.cusacb
            customer.card_number = cusmas.cuscno
            customer.card_expiry = cusmas.cuscex
            customer.card_name = cusmas.cuscnm
        endmethod

        ;;; <summary>
        ;;; Maps a CUSTOMER record into a CUSMAS record
        ;;; </summary>
        ;;; <param name="ctmst">Passed CUSTOMER record</param>
        ;;; <param name="customer">Returned CUSMAS record</param>
        public method Unmap, void
            required in  customer, strCustomer
            required out cusmas, strCUSMAS
            endparams
        proc
            cusmas.cusacc = customer.account
            cusmas.cusnam = customer.company
            cusmas.cusad1 = customer.street
            cusmas.cusad2 = customer.city
            cusmas.cusad3 = customer.state
            cusmas.cusad4 = customer.zip
            cusmas.cuspno = customer.phone_number
            cusmas.cusfno = customer.fax_number
            cusmas.cusmno = customer.mobile_number
            cusmas.cuspgn = customer.pager_number
            cusmas.cusem1 = customer.email1
            cusmas.cusem2 = customer.email2
            cusmas.cusdao = customer.date_opened
            cusmas.cusdah = customer.date_hold
            cusmas.cusdac = customer.date_closed
            cusmas.cusast = customer.status
            cusmas.cusclm = customer.limit
            cusmas.cusacb = customer.balance
            cusmas.cuscno = customer.card_number
            cusmas.cuscex = customer.card_expiry
            cusmas.cuscnm = customer.card_name
        endmethod

        ;;; <summary>
        ;;; Loads field details into the recordSpec record
        ;;; </summary>
        private method loadRecordSpec, void
            endparams
        proc
            recordSpec.fieldCount = 21
            recordSpec.fields[1].fieldType     = "A" ;;Account
            recordSpec.fields[1].fieldSize     = 8
            recordSpec.fields[1].fieldDecimals = 0
            recordSpec.fields[2].fieldType     = "A" ;;Company
            recordSpec.fields[2].fieldSize     = 40
            recordSpec.fields[2].fieldDecimals = 0
            recordSpec.fields[3].fieldType     = "A" ;;Street
            recordSpec.fields[3].fieldSize     = 40
            recordSpec.fields[3].fieldDecimals = 0
            recordSpec.fields[4].fieldType     = "A" ;;City
            recordSpec.fields[4].fieldSize     = 25
            recordSpec.fields[4].fieldDecimals = 0
            recordSpec.fields[5].fieldType     = "A" ;;State
            recordSpec.fields[5].fieldSize     = 2
            recordSpec.fields[5].fieldDecimals = 0
            recordSpec.fields[6].fieldType     = "D" ;;Zip
            recordSpec.fields[6].fieldSize     = 5
            recordSpec.fields[6].fieldDecimals = 0
            recordSpec.fields[7].fieldType     = "D" ;;PhoneNumber
            recordSpec.fields[7].fieldSize     = 10
            recordSpec.fields[7].fieldDecimals = 0
            recordSpec.fields[8].fieldType     = "D" ;;FaxNumber
            recordSpec.fields[8].fieldSize     = 10
            recordSpec.fields[8].fieldDecimals = 0
            recordSpec.fields[9].fieldType     = "D" ;;MobileNumber
            recordSpec.fields[9].fieldSize     = 10
            recordSpec.fields[9].fieldDecimals = 0
            recordSpec.fields[10].fieldType     = "D" ;;PagerNumber
            recordSpec.fields[10].fieldSize     = 10
            recordSpec.fields[10].fieldDecimals = 0
            recordSpec.fields[11].fieldType     = "A" ;;Email1
            recordSpec.fields[11].fieldSize     = 80
            recordSpec.fields[11].fieldDecimals = 0
            recordSpec.fields[12].fieldType     = "A" ;;Email2
            recordSpec.fields[12].fieldSize     = 80
            recordSpec.fields[12].fieldDecimals = 0
            recordSpec.fields[13].fieldType     = "A" ;;DateOpened
            recordSpec.fields[13].fieldSize     = 8
            recordSpec.fields[13].fieldDecimals = 0
            recordSpec.fields[14].fieldType     = "A" ;;DateHold
            recordSpec.fields[14].fieldSize     = 8
            recordSpec.fields[14].fieldDecimals = 0
            recordSpec.fields[15].fieldType     = "A" ;;DateClosed
            recordSpec.fields[15].fieldSize     = 8
            recordSpec.fields[15].fieldDecimals = 0
            recordSpec.fields[16].fieldType     = "D" ;;Status
            recordSpec.fields[16].fieldSize     = 1
            recordSpec.fields[16].fieldDecimals = 0
            recordSpec.fields[17].fieldType     = "D" ;;Limit
            recordSpec.fields[17].fieldSize     = 10
            recordSpec.fields[17].fieldDecimals = 2
            recordSpec.fields[18].fieldType     = "D" ;;Balance
            recordSpec.fields[18].fieldSize     = 10
            recordSpec.fields[18].fieldDecimals = 2
            recordSpec.fields[19].fieldType     = "A" ;;CardNumber
            recordSpec.fields[19].fieldSize     = 16
            recordSpec.fields[19].fieldDecimals = 0
            recordSpec.fields[20].fieldType     = "D" ;;CardExpiry
            recordSpec.fields[20].fieldSize     = 4
            recordSpec.fields[20].fieldDecimals = 0
            recordSpec.fields[21].fieldType     = "A" ;;CardName
            recordSpec.fields[21].fieldSize     = 25
            recordSpec.fields[21].fieldDecimals = 0
        endmethod

        ;;; <summary>
        ;;; Loads various SQL statements into "shared" static variables
        ;;; </summary>
        private method loadSqlStatements, void
            endparams
        proc

            if (mCreateTableStatement==^null)
                mCreateTableStatement = "CREATE TABLE Customer ("
                & "Account VARCHAR(8) NOT NULL,"
                & "Company VARCHAR(40) NOT NULL,"
                & "Street VARCHAR(40) NOT NULL,"
                & "City VARCHAR(25) NOT NULL,"
                & "State VARCHAR(2) NOT NULL,"
                & "Zip DECIMAL(5) NOT NULL,"
                & "PhoneNumber DECIMAL(10),"
                & "FaxNumber DECIMAL(10),"
                & "MobileNumber DECIMAL(10),"
                & "PagerNumber DECIMAL(10),"
                & "Email1 VARCHAR(80),"
                & "Email2 VARCHAR(80),"
                & "DateOpened DATE NOT NULL,"
                & "DateHold DATE,"
                & "DateClosed DATE,"
                & "Status DECIMAL(1) NOT NULL,"
                & "Limit DECIMAL(10,2) NOT NULL,"
                & "Balance DECIMAL(10,2),"
                & "CardNumber VARCHAR(16),"
                & "CardExpiry DECIMAL(4),"
                & "CardName VARCHAR(25),"
                & "CONSTRAINT PK_Customer PRIMARY KEY CLUSTERED (Account ASC))"

            if (mInsertStatement==^null)
                mInsertStatement = "INSERT INTO Customer ("
                & "Account,"
                & "Company,"
                & "Street,"
                & "City,"
                & "State,"
                & "Zip,"
                & "PhoneNumber,"
                & "FaxNumber,"
                & "MobileNumber,"
                & "PagerNumber,"
                & "Email1,"
                & "Email2,"
                & "DateOpened,"
                & "DateHold,"
                & "DateClosed,"
                & "Status,"
                & "Limit,"
                & "Balance,"
                & "CardNumber,"
                & "CardExpiry,"
                & "CardName"
                & ") VALUES(:1,:2,:3,:4,:5,:6,:7,:8,:9,:10,:11,:12,:13,:14,:15,:16,:17,:18,:19,:20,:21)"

            if (mSelectByKeyStatement==^null)
                mSelectByKeyStatement = "SELECT "
                & "Account,"
                & "Company,"
                & "Street,"
                & "City,"
                & "State,"
                & "Zip,"
                & "PhoneNumber,"
                & "FaxNumber,"
                & "MobileNumber,"
                & "PagerNumber,"
                & "Email1,"
                & "Email2,"
                & "DateOpened,"
                & "DateHold,"
                & "DateClosed,"
                & "Status,"
                & "Limit,"
                & "Balance,"
                & "CardNumber,"
                & "CardExpiry,"
                & "CardName"
                & " FROM Customer"
                & " WHERE  Account=:1 "

            if (mSelectAllStatement==^null)
                mSelectAllStatement = "SELECT "
                & "Account,"
                & "Company,"
                & "Street,"
                & "City,"
                & "State,"
                & "Zip,"
                & "PhoneNumber,"
                & "FaxNumber,"
                & "MobileNumber,"
                & "PagerNumber,"
                & "Email1,"
                & "Email2,"
                & "DateOpened,"
                & "DateHold,"
                & "DateClosed,"
                & "Status,"
                & "Limit,"
                & "Balance,"
                & "CardNumber,"
                & "CardExpiry,"
                & "CardName"
                & " FROM Customer"

            if (mDeleteByKeyStatement==^null)
                mDeleteByKeyStatement = "DELETE FROM Customer WHERE  Account=:1 "

        endmethod

    endclass

endnamespace

